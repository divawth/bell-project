(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["yox"],{

/***/ "./node_modules/yox/dist/standard/dev/yox.js":
/*!***************************************************!*\
  !*** ./node_modules/yox/dist/standard/dev/yox.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(setImmediate) {/**\n * yox.js v1.0.0-alpha.35\n * (c) 2017-2019 musicode\n * Released under the MIT License.\n */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, function () { 'use strict';\n\n  /**\n   * 为了压缩，定义的常量\n   */\n  var TRUE = true;\n  var FALSE = false;\n  var NULL = null;\n  var UNDEFINED = void 0;\n  var RAW_TRUE = 'true';\n  var RAW_FALSE = 'false';\n  var RAW_NULL = 'null';\n  var RAW_UNDEFINED = 'undefined';\n  var RAW_KEY = 'key';\n  var RAW_REF = 'ref';\n  var RAW_SLOT = 'slot';\n  var RAW_NAME = 'name';\n  var RAW_FILTER = 'filter';\n  var RAW_PARTIAL = 'partial';\n  var RAW_COMPONENT = 'component';\n  var RAW_DIRECTIVE = 'directive';\n  var RAW_TRANSITION = 'transition';\n  var RAW_THIS = 'this';\n  var RAW_VALUE = 'value';\n  var RAW_LENGTH = 'length';\n  var RAW_FUNCTION = 'function';\n  var RAW_TEMPLATE = 'template';\n  var RAW_WILDCARD = '*';\n  var KEYPATH_PARENT = '..';\n  var KEYPATH_CURRENT = RAW_THIS;\n  /**\n   * Single instance for window in browser\n   */\n  var WINDOW = typeof window !== RAW_UNDEFINED ? window : UNDEFINED;\n  /**\n   * Single instance for document in browser\n   */\n  var DOCUMENT = typeof document !== RAW_UNDEFINED ? document : UNDEFINED;\n  /**\n   * tap 事件\n   *\n   * 非常有用的抽象事件，比如 pc 端是 click 事件，移动端是 touchend 事件\n   *\n   * 这样只需 on-tap=\"handler\" 就可以完美兼容各端\n   *\n   * 框架未实现此事件，通过 Yox.dom.specialEvents 提供给外部扩展\n   *\n   */\n  var EVENT_TAP = 'tap';\n  /**\n   * 点击事件\n   */\n  var EVENT_CLICK = 'click';\n  /**\n   * 输入事件\n   */\n  var EVENT_INPUT = 'input';\n  /**\n   * 变化事件\n   */\n  var EVENT_CHANGE = 'change';\n  /**\n   * 唯一内置的特殊事件：model\n   */\n  var EVENT_MODEL = 'model';\n  /**\n   * Single instance for noop function\n   */\n  var EMPTY_FUNCTION = function () {\n      /** yox */\n  };\n  /**\n   * 空对象，很多地方会用到，比如 `a || EMPTY_OBJECT` 确保是个对象\n   */\n  var EMPTY_OBJECT = Object.freeze({});\n  /**\n   * 空数组\n   */\n  var EMPTY_ARRAY = Object.freeze([]);\n  /**\n   * 空字符串\n   */\n  var EMPTY_STRING = '';\n\n  function isDef (target) {\n      return target !== UNDEFINED;\n  }\n\n  /**\n   * Check if value is a function.\n   *\n   * @param value\n   * @return\n   */\n  function func(value) {\n      return typeof value === RAW_FUNCTION;\n  }\n  /**\n   * Check if value is an array.\n   *\n   * @param value\n   * @return\n   */\n  function array(value) {\n      return Array.isArray(value);\n  }\n  /**\n   * Check if value is an object.\n   *\n   * @param value\n   * @return\n   */\n  function object(value) {\n      // 低版本 IE 会把 null 和 undefined 当作 object\n      return value !== NULL && typeof value === 'object';\n  }\n  /**\n   * Check if value is a string.\n   *\n   * @param value\n   * @return\n   */\n  function string(value) {\n      return typeof value === 'string';\n  }\n  /**\n   * Check if value is a number.\n   *\n   * @param value\n   * @return\n   */\n  function number(value) {\n      return typeof value === 'number';\n  }\n  /**\n   * Check if value is boolean.\n   *\n   * @param value\n   * @return\n   */\n  function boolean(value) {\n      return typeof value === 'boolean';\n  }\n  /**\n   * Check if value is numeric.\n   *\n   * @param value\n   * @return\n   */\n  function numeric(value) {\n      return number(value)\n          || (string(value) && !isNaN(parseFloat(value)) && isFinite(value));\n  }\n\n  var is = /*#__PURE__*/Object.freeze({\n    func: func,\n    array: array,\n    object: object,\n    string: string,\n    number: number,\n    boolean: boolean,\n    numeric: numeric\n  });\n\n  /**\n   * 任性地执行一个函数，不管它有没有、是不是\n   *\n   * @param fn 调用的函数\n   * @param context 执行函数时的 this 指向\n   * @param args 调用函数的参数，多参数时传入数组\n   * @return 调用函数的返回值\n   */\n  function execute (fn, context, args) {\n      if (func(fn)) {\n          return array(args)\n              ? fn.apply(context, args)\n              : isDef(context)\n                  ? fn.call(context, args)\n                  : isDef(args)\n                      ? fn(args)\n                      : fn();\n      }\n  }\n\n  var CustomEvent = /** @class */ (function () {\n      /**\n       * 构造函数\n       *\n       * 可以传事件名称，也可以传原生事件对象\n       */\n      function CustomEvent(type, originalEvent) {\n          this.type = type;\n          this.phase = CustomEvent.PHASE_CURRENT;\n          if (originalEvent) {\n              this.originalEvent = originalEvent;\n          }\n      }\n      /**\n       * 阻止事件的默认行为\n       */\n      CustomEvent.prototype.preventDefault = function () {\n          var instance = this;\n          if (!instance.isPrevented) {\n              var originalEvent = instance.originalEvent;\n              if (originalEvent) {\n                  originalEvent.preventDefault();\n              }\n              instance.isPrevented = TRUE;\n          }\n          return instance;\n      };\n      /**\n       * 停止事件广播\n       */\n      CustomEvent.prototype.stopPropagation = function () {\n          var instance = this;\n          if (!instance.isStoped) {\n              var originalEvent = instance.originalEvent;\n              if (originalEvent) {\n                  originalEvent.stopPropagation();\n              }\n              instance.isStoped = TRUE;\n          }\n          return instance;\n      };\n      CustomEvent.prototype.prevent = function () {\n          return this.preventDefault();\n      };\n      CustomEvent.prototype.stop = function () {\n          return this.stopPropagation();\n      };\n      CustomEvent.PHASE_CURRENT = 0;\n      CustomEvent.PHASE_UPWARD = 1;\n      CustomEvent.PHASE_DOWNWARD = -1;\n      return CustomEvent;\n  }());\n\n  /**\n   * 遍历数组\n   *\n   * @param array\n   * @param callback 返回 false 可停止遍历\n   * @param reversed 是否逆序遍历\n   */\n  function each(array, callback, reversed) {\n      var length = array.length;\n      if (length) {\n          if (reversed) {\n              for (var i = length - 1; i >= 0; i--) {\n                  if (callback(array[i], i, length) === FALSE) {\n                      break;\n                  }\n              }\n          }\n          else {\n              for (var i = 0; i < length; i++) {\n                  if (callback(array[i], i, length) === FALSE) {\n                      break;\n                  }\n              }\n          }\n      }\n  }\n  function nativePush(array, item) {\n      array[array.length] = item;\n  }\n  function nativeUnshift(array, item) {\n      array.unshift(item);\n  }\n  /**\n   * 添加\n   *\n   * @param array\n   * @param value\n   * @param action\n   */\n  function addItem(array$1, value, action) {\n      if (array(value)) {\n          each(value, function (item) {\n              action(array$1, item);\n          });\n      }\n      else {\n          action(array$1, value);\n      }\n  }\n  /**\n   * 往后加\n   *\n   * @param array\n   * @param target\n   */\n  function push(array, target) {\n      addItem(array, target, nativePush);\n  }\n  /**\n   * 往前加\n   *\n   * @param array\n   * @param target\n   */\n  function unshift(array, target) {\n      addItem(array, target, nativeUnshift);\n  }\n  /**\n   * 数组项在数组中的位置\n   *\n   * @param array 数组\n   * @param target 数组项\n   * @param strict 是否全等判断，默认是全等\n   * @return 如果未找到，返回 -1\n   */\n  function indexOf(array, target, strict) {\n      var result = -1;\n      each(array, function (item, index) {\n          if (strict === FALSE ? item == target : item === target) {\n              result = index;\n              return FALSE;\n          }\n      });\n      return result;\n  }\n  /**\n   * 获取数组最后一项\n   *\n   * @param array 数组\n   * @return\n   */\n  function last(array) {\n      var length = array.length;\n      if (length > 0) {\n          return array[length - 1];\n      }\n  }\n  /**\n   * 弹出数组最后一项\n   *\n   * 项目里用的太多，仅用于节省字符...\n   *\n   * @param array 数组\n   * @return 弹出的数组项\n   */\n  function pop(array) {\n      var length = array.length;\n      if (length > 0) {\n          return array.pop();\n      }\n  }\n  /**\n   * 删除数组项\n   *\n   * @param array 数组\n   * @param item 待删除项\n   * @param strict 是否全等判断，默认是全等\n   * @return 删除的数量\n   */\n  function remove(array, target, strict) {\n      var result = 0;\n      each(array, function (item, index) {\n          if (strict === FALSE ? item == target : item === target) {\n              array.splice(index, 1);\n              result++;\n          }\n      }, TRUE);\n      return result;\n  }\n  /**\n   * 数组是否包含 item\n   *\n   * @param array 数组\n   * @param target 可能包含的数组项\n   * @param strict 是否全等判断，默认是全等\n   * @return\n   */\n  function has(array, target, strict) {\n      return indexOf(array, target, strict) >= 0;\n  }\n  /**\n   * 把类数组转成数组\n   *\n   * @param array 类数组\n   * @return\n   */\n  function toArray(array$1) {\n      return array(array$1)\n          ? array$1\n          : execute(EMPTY_ARRAY.slice, array$1);\n  }\n  /**\n   * 把数组转成对象\n   *\n   * @param array 数组\n   * @param key 数组项包含的字段名称，如果数组项是基本类型，可不传\n   * @param value\n   * @return\n   */\n  function toObject(array, key, value) {\n      var result = {};\n      each(array, function (item) {\n          result[key ? item[key] : item] = value || item;\n      });\n      return result;\n  }\n  /**\n   * 把数组合并成字符串\n   *\n   * @param array\n   * @param separator\n   * @return\n   */\n  function join(array, separator) {\n      return array.join(separator);\n  }\n  /**\n   * 用于判断长度大于 0 的数组\n   *\n   * @param array\n   * @return\n   */\n  function falsy(array$1) {\n      return !array(array$1) || !array$1.length;\n  }\n\n  var array$1 = /*#__PURE__*/Object.freeze({\n    each: each,\n    push: push,\n    unshift: unshift,\n    indexOf: indexOf,\n    last: last,\n    pop: pop,\n    remove: remove,\n    has: has,\n    toArray: toArray,\n    toObject: toObject,\n    join: join,\n    falsy: falsy\n  });\n\n  var camelizePattern = /-([a-z])/gi, hyphenatePattern = /\\B([A-Z])/g, capitalizePattern = /^[a-z]/, camelizeCache = {}, hyphenateCache = {}, capitalizeCache = {};\n  /**\n   * 连字符转成驼峰\n   *\n   * @param str\n   * @return 驼峰格式的字符串\n   */\n  function camelize(str) {\n      if (!camelizeCache[str]) {\n          camelizeCache[str] = str.replace(camelizePattern, function ($0, $1) {\n              return upper($1);\n          });\n      }\n      return camelizeCache[str];\n  }\n  /**\n   * 驼峰转成连字符\n   *\n   * @param str\n   * @return 连字符格式的字符串\n   */\n  function hyphenate(str) {\n      if (!hyphenateCache[str]) {\n          hyphenateCache[str] = str.replace(hyphenatePattern, function ($0, $1) {\n              return '-' + lower($1);\n          });\n      }\n      return hyphenateCache[str];\n  }\n  /**\n   * 首字母大写\n   *\n   * @param str\n   * @return\n   */\n  function capitalize(str) {\n      if (!capitalizeCache[str]) {\n          capitalizeCache[str] = str.replace(capitalizePattern, upper);\n      }\n      return capitalizeCache[str];\n  }\n  /**\n   * 清除两侧空白符\n   *\n   * @param str\n   * @return 清除两侧空白符的字符串\n   */\n  function trim(str) {\n      return falsy$1(str)\n          ? EMPTY_STRING\n          : str.trim();\n  }\n  /**\n   * 截取字符串\n   *\n   * @param str\n   * @param start\n   * @param end\n   * @return\n   */\n  function slice(str, start, end) {\n      return number(end)\n          ? start === end\n              ? EMPTY_STRING\n              : str.slice(start, end)\n          : str.slice(start);\n  }\n  /**\n   * 获取子串的起始位置\n   *\n   * @param str\n   * @param part\n   * @param start\n   * @return\n   */\n  function indexOf$1(str, part, start) {\n      return str.indexOf(part, isDef(start) ? start : 0);\n  }\n  /**\n   * 获取子串的起始位置\n   *\n   * @param str\n   * @param part\n   * @param end\n   * @return\n   */\n  function lastIndexOf(str, part, end) {\n      return str.lastIndexOf(part, isDef(end) ? end : str.length);\n  }\n  /**\n   * str 是否以 part 开头\n   *\n   * @param str\n   * @param part\n   * @return\n   */\n  function startsWith(str, part) {\n      return indexOf$1(str, part) === 0;\n  }\n  /**\n   * str 是否以 part 结束\n   *\n   * @param str\n   * @param part\n   * @return\n   */\n  function endsWith(str, part) {\n      var offset = str.length - part.length;\n      return offset >= 0 && lastIndexOf(str, part) === offset;\n  }\n  /**\n   * 获取某个位置的字符\n   */\n  function charAt(str, index) {\n      return str.charAt(index || 0);\n  }\n  /**\n   * 获取某个位置的字符编码\n   */\n  function codeAt(str, index) {\n      return str.charCodeAt(index || 0);\n  }\n  /**\n   * 大写格式\n   */\n  function upper(str) {\n      return str.toUpperCase();\n  }\n  /**\n   * 小写格式\n   */\n  function lower(str) {\n      return str.toLowerCase();\n  }\n  /**\n   * str 是否包含 part\n   *\n   * @param str\n   * @param part\n   * @return 是否包含\n   */\n  function has$1(str, part) {\n      return indexOf$1(str, part) >= 0;\n  }\n  /**\n   * 判断长度大于 0 的字符串\n   *\n   * @param str\n   * @return\n   */\n  function falsy$1(str) {\n      return !string(str) || !str.length;\n  }\n\n  var string$1 = /*#__PURE__*/Object.freeze({\n    camelize: camelize,\n    hyphenate: hyphenate,\n    capitalize: capitalize,\n    trim: trim,\n    slice: slice,\n    indexOf: indexOf$1,\n    lastIndexOf: lastIndexOf,\n    startsWith: startsWith,\n    endsWith: endsWith,\n    charAt: charAt,\n    codeAt: codeAt,\n    upper: upper,\n    lower: lower,\n    has: has$1,\n    falsy: falsy$1\n  });\n\n  var SEP_DOT = '.', dotPattern = /\\./g, asteriskPattern = /\\*/g, doubleAsteriskPattern = /\\*\\*/g, splitCache = {}, patternCache = {};\n  /**\n   * 判断 keypath 是否以 prefix 开头，如果是，返回匹配上的前缀长度，否则返回 -1\n   *\n   * @param keypath\n   * @param prefix\n   * @return\n   */\n  function match(keypath, prefix) {\n      if (keypath === prefix) {\n          return prefix.length;\n      }\n      prefix += SEP_DOT;\n      return startsWith(keypath, prefix)\n          ? prefix.length\n          : -1;\n  }\n  /**\n   * 遍历 keypath 的每个部分\n   *\n   * @param keypath\n   * @param callback 返回 false 可中断遍历\n   */\n  function each$1(keypath, callback) {\n      // 判断字符串是因为 keypath 有可能是 toString\n      // 而 splitCache.toString 是个函数\n      var list = isDef(splitCache[keypath])\n          ? splitCache[keypath]\n          : (splitCache[keypath] = keypath.split(SEP_DOT));\n      for (var i = 0, lastIndex = list.length - 1; i <= lastIndex; i++) {\n          if (callback(list[i], i === lastIndex) === FALSE) {\n              break;\n          }\n      }\n  }\n  /**\n   * 遍历 keypath 的每个部分\n   *\n   * @param keypath1\n   * @param keypath2\n   */\n  function join$1(keypath1, keypath2) {\n      return keypath1 && keypath2\n          ? keypath1 + SEP_DOT + keypath2\n          : keypath1 || keypath2;\n  }\n  /**\n   * 是否模糊匹配\n   *\n   * @param keypath\n   */\n  function isFuzzy(keypath) {\n      return has$1(keypath, RAW_WILDCARD);\n  }\n  /**\n   * 模糊匹配 keypath\n   *\n   * @param keypath\n   * @param pattern\n   */\n  function matchFuzzy(keypath, pattern) {\n      var cache = patternCache[pattern];\n      if (!cache) {\n          var str = pattern\n              .replace(dotPattern, '\\\\.')\n              .replace(asteriskPattern, '(\\\\w+)')\n              .replace(doubleAsteriskPattern, '([\\.\\\\w]+?)');\n          cache = patternCache[pattern] = new RegExp(\"^\" + str + \"$\");\n      }\n      var result = keypath.match(cache);\n      if (result) {\n          return result[1];\n      }\n  }\n\n  /**\n   * 获取对象的 key 的数组\n   *\n   * @param object\n   * @return\n   */\n  function keys(object) {\n      return Object.keys(object);\n  }\n  function sortKeyByAsc(a, b) {\n      return a.length - b.length;\n  }\n  function sortKeyByDesc(a, b) {\n      return b.length - a.length;\n  }\n  /**\n   * 排序对象的 key\n   *\n   * @param object\n   * @param desc 是否逆序，默认从小到大排序\n   * @return\n   */\n  function sort(object, desc) {\n      return keys(object).sort(desc ? sortKeyByDesc : sortKeyByAsc);\n  }\n  /**\n   * 遍历对象\n   *\n   * @param object\n   * @param callback 返回 false 可停止遍历\n   */\n  function each$2(object, callback) {\n      for (var key in object) {\n          if (callback(object[key], key) === FALSE) {\n              break;\n          }\n      }\n  }\n  /**\n   * 清空对象所有的键值对\n   *\n   * @param object\n   */\n  function clear(object) {\n      each$2(object, function (_, key) {\n          delete object[key];\n      });\n  }\n  /**\n   * 扩展对象\n   *\n   * @return\n   */\n  function extend(original) {\n      var arguments$1 = arguments;\n\n      var objects = [];\n      for (var _i = 1; _i < arguments.length; _i++) {\n          objects[_i - 1] = arguments$1[_i];\n      }\n      each(objects, function (object) {\n          each$2(object, function (value, key) {\n              original[key] = value;\n          });\n      });\n      return original;\n  }\n  /**\n   * 拷贝对象\n   *\n   * @param object\n   * @param deep 是否需要深拷贝\n   * @return\n   */\n  function copy(object$1, deep) {\n      var result = object$1;\n      if (array(object$1)) {\n          if (deep) {\n              result = [];\n              each(object$1, function (item, index) {\n                  result[index] = copy(item, deep);\n              });\n          }\n          else {\n              result = object$1.slice();\n          }\n      }\n      else if (object(object$1)) {\n          result = {};\n          each$2(object$1, function (value, key) {\n              result[key] = deep ? copy(value, deep) : value;\n          });\n      }\n      return result;\n  }\n  /**\n   * 辅助 get 函数，持有最后找到的值，避免频繁的创建临时对象\n   */\n  var valueHolder = {\n      value: UNDEFINED\n  };\n  /**\n   * 从对象中查找一个 keypath\n   *\n   * 返回值是空时，表示没找到值\n   *\n   * @param object\n   * @param keypath\n   * @return\n   */\n  function get(object, keypath) {\n      /**\n       * 考虑以下情况:\n       *\n       * {\n       *   'a.b.c.d': 1,\n       *   'a.b.c': {\n       *      d: 2\n       *   }\n       * }\n       *\n       * 此时 keypath 是 `a.b.c.d`，可以获取到 1\n       * 如果没有这个 key，按 keypath 推进是取不到值的，因为没有 a.b.c 对象\n       * 个人觉得没有必要支持字面量，情况实在太多，会把这个函数搞的性能很差\n       */\n      each$1(keypath, function (key, isLast) {\n          if (object != NULL) {\n              // 先直接取值\n              var value = object[key], \n              // 紧接着判断值是否存在\n              // 下面会处理计算属性的值，不能在它后面设置 hasValue\n              hasValue = isDef(value);\n              // 如果是计算属性，取计算属性的值\n              if (value && func(value.get)) {\n                  value = value.get();\n              }\n              if (isLast) {\n                  if (hasValue) {\n                      valueHolder.value = value;\n                      object = valueHolder;\n                  }\n                  else {\n                      object = UNDEFINED;\n                  }\n              }\n              else {\n                  object = value;\n              }\n          }\n          else {\n              object = UNDEFINED;\n              return FALSE;\n          }\n      });\n      return object;\n  }\n  /**\n   * 为对象设置一个键值对\n   *\n   * @param object\n   * @param keypath\n   * @param value\n   * @param autofill 是否自动填充不存在的对象，默认自动填充\n   */\n  function set(object, keypath, value, autofill) {\n      each$1(keypath, function (key, isLast) {\n          if (isLast) {\n              object[key] = value;\n          }\n          else if (object[key]) {\n              object = object[key];\n          }\n          else if (autofill) {\n              object = object[key] = {};\n          }\n          else {\n              return FALSE;\n          }\n      });\n  }\n  /**\n   * 对象是否包含某个 key\n   *\n   * @param object\n   * @param key\n   * @return\n   */\n  function has$2(object, key) {\n      // 不用 hasOwnProperty，性能差\n      return isDef(object[key]);\n  }\n  /**\n   * 是否是空对象\n   *\n   * @param object\n   * @return\n   */\n  function falsy$2(object$1) {\n      return !object(object$1)\n          || array(object$1)\n          || !keys(object$1).length;\n  }\n\n  var object$1 = /*#__PURE__*/Object.freeze({\n    keys: keys,\n    sort: sort,\n    each: each$2,\n    clear: clear,\n    extend: extend,\n    copy: copy,\n    get: get,\n    set: set,\n    has: has$2,\n    falsy: falsy$2\n  });\n\n  function toString (target, defaultValue) {\n      return target != NULL && target.toString\n          ? target.toString()\n          : isDef(defaultValue)\n              ? defaultValue\n              : EMPTY_STRING;\n  }\n\n  var DEBUG = 1;\n  var INFO = 2;\n  var WARN = 3;\n  var ERROR = 4;\n  var FATAL = 5;\n  /**\n   * 是否有原生的日志特性，没有必要单独实现\n   */\n  var nativeConsole = typeof console !== RAW_UNDEFINED ? console : NULL, \n  /**\n   * 当前是否是源码调试，如果开启了代码压缩，empty function 里的注释会被干掉\n   */\n  level = /yox/.test(toString(EMPTY_FUNCTION)) ? DEBUG : WARN, \n  /**\n   * console 样式前缀\n   */\n  stylePrefix = '%c';\n  /**\n   * 全局调试开关\n   */\n  function getLevel() {\n      if (WINDOW) {\n          var logLevel = WINDOW['YOX_LOG_LEVEL'];\n          if (logLevel >= DEBUG && logLevel <= FATAL) {\n              return logLevel;\n          }\n      }\n      return level;\n  }\n  function getStyle(backgroundColor) {\n      return \"background-color:\" + backgroundColor + \";border-radius:20px;color:#fff;font-size:10px;padding:3px 6px;\";\n  }\n  /**\n   * 打印 debug 日志\n   *\n   * @param msg\n   */\n  function debug(msg, tag) {\n      if (nativeConsole && getLevel() <= DEBUG) {\n          nativeConsole.log(stylePrefix + (tag || 'Yox debug'), getStyle('#888'), msg);\n      }\n  }\n  /**\n   * 打印 info 日志\n   *\n   * @param msg\n   */\n  function info(msg, tag) {\n      if (nativeConsole && getLevel() <= INFO) {\n          nativeConsole.log(stylePrefix + (tag || 'Yox info'), getStyle('#2db7f5'), msg);\n      }\n  }\n  /**\n   * 打印 warn 日志\n   *\n   * @param msg\n   */\n  function warn(msg, tag) {\n      if (nativeConsole && getLevel() <= WARN) {\n          nativeConsole.warn(stylePrefix + (tag || 'Yox warn'), getStyle('#f90'), msg);\n      }\n  }\n  /**\n   * 打印 error 日志\n   *\n   * @param msg\n   */\n  function error(msg, tag) {\n      if (nativeConsole && getLevel() <= ERROR) {\n          nativeConsole.error(stylePrefix + (tag || 'Yox error'), getStyle('#ed4014'), msg);\n      }\n  }\n  /**\n   * 致命错误，中断程序\n   *\n   * @param msg\n   */\n  function fatal(msg, tag) {\n      if (getLevel() <= FATAL) {\n          throw new Error(\"[\" + (tag || 'Yox fatal') + \"]: \" + msg);\n      }\n  }\n\n  var logger = /*#__PURE__*/Object.freeze({\n    DEBUG: DEBUG,\n    INFO: INFO,\n    WARN: WARN,\n    ERROR: ERROR,\n    FATAL: FATAL,\n    debug: debug,\n    info: info,\n    warn: warn,\n    error: error,\n    fatal: fatal\n  });\n\n  var Emitter = /** @class */ (function () {\n      function Emitter(ns) {\n          this.ns = ns || FALSE;\n          this.listeners = {};\n      }\n      /**\n       * 发射事件\n       *\n       * @param bullet 事件或事件名称\n       * @param data 事件数据\n       */\n      Emitter.prototype.fire = function (type, args, filter) {\n          var instance = this, _a = parseNamespace(instance.ns, type), name = _a.name, ns = _a.ns, list = instance.listeners[name], isComplete = TRUE;\n          if (list) {\n              // 避免遍历过程中，数组发生变化，比如增删了\n              list = copy(list);\n              // 判断是否是发射事件\n              // 如果 args 的第一个参数是 CustomEvent 类型，表示发射事件\n              // 因为事件处理函数的参数列表是 (event, data)\n              var event_1 = args && args[0] instanceof CustomEvent\n                  ? args[0]\n                  : UNDEFINED;\n              each(list, function (options, _) {\n                  // 命名空间不匹配\n                  if (!matchNamespace(ns, options)\n                      // 在 fire 过程中被移除了\n                      || !has(list, options)\n                      // 传了 filter，则用 filter 判断是否过滤此 options\n                      || (filter && !filter(type, args, options))) {\n                      return;\n                  }\n                  // 为 event 对象加上当前正在处理的 listener\n                  // 这样方便业务层移除事件绑定\n                  // 比如 on('xx', function) 这样定义了匿名 listener\n                  // 在这个 listener 里面获取不到当前 listener 的引用\n                  // 为了能引用到，有时候会先定义 var listener = function,\n                  // 然后再 on('xx', listener) 这样其实是没有必要的\n                  if (event_1) {\n                      event_1.listener = options.fn;\n                  }\n                  var result = execute(options.fn, options.ctx, args);\n                  if (event_1) {\n                      event_1.listener = UNDEFINED;\n                  }\n                  // 执行次数\n                  options.num = options.num ? (options.num + 1) : 1;\n                  // 注册的 listener 可以指定最大执行次数\n                  if (options.num === options.max) {\n                      instance.off(type, options.fn);\n                  }\n                  // 如果没有返回 false，而是调用了 event.stop 也算是返回 false\n                  if (event_1) {\n                      if (result === FALSE) {\n                          event_1.prevent().stop();\n                      }\n                      else if (event_1.isStoped) {\n                          result = FALSE;\n                      }\n                  }\n                  if (result === FALSE) {\n                      return isComplete = FALSE;\n                  }\n              });\n          }\n          return isComplete;\n      };\n      /**\n       * 注册监听\n       *\n       * @param type\n       * @param listener\n       */\n      Emitter.prototype.on = function (type, listener) {\n          var instance = this, listeners = instance.listeners, options = func(listener)\n              ? { fn: listener }\n              : listener;\n          if (object(options) && func(options.fn)) {\n              var _a = parseNamespace(instance.ns, type), name = _a.name, ns = _a.ns;\n              options.ns = ns;\n              push(listeners[name] || (listeners[name] = []), options);\n          }\n          else {\n              fatal(\"Invoke emitter.on(type, listener) failed.\");\n          }\n      };\n      /**\n       * 取消监听\n       *\n       * @param type\n       * @param listener\n       */\n      Emitter.prototype.off = function (type, listener) {\n          var instance = this, listeners = instance.listeners;\n          if (type) {\n              var _a = parseNamespace(instance.ns, type), name = _a.name, ns_1 = _a.ns, matchListener_1 = createMatchListener(listener), each$1 = function (list, name) {\n                  each(list, function (options, index) {\n                      if (matchListener_1(options) && matchNamespace(ns_1, options)) {\n                          list.splice(index, 1);\n                      }\n                  }, TRUE);\n                  if (!list.length) {\n                      delete listeners[name];\n                  }\n              };\n              if (name) {\n                  if (listeners[name]) {\n                      each$1(listeners[name], name);\n                  }\n              }\n              else if (ns_1) {\n                  each$2(listeners, each$1);\n              }\n          }\n          else {\n              // 清空\n              instance.listeners = {};\n              // 在开发阶段进行警告，比如传了 type 进来，type 是个空值\n              // 但你不知道它是空值\n              {\n                  if (arguments.length > 0) {\n                      warn(\"emitter.off(type) is invoked, but the \\\"type\\\" argument is undefined or null.\");\n                  }\n              }\n          }\n      };\n      /**\n       * 是否已监听某个事件\n       *\n       * @param type\n       * @param listener\n       */\n      Emitter.prototype.has = function (type, listener) {\n          var instance = this, listeners = instance.listeners, _a = parseNamespace(instance.ns, type), name = _a.name, ns = _a.ns, result = TRUE, matchListener = createMatchListener(listener), each$1 = function (list) {\n              each(list, function (options) {\n                  if (matchListener(options) && matchNamespace(ns, options)) {\n                      return result = FALSE;\n                  }\n              });\n              return result;\n          };\n          if (name) {\n              if (listeners[name]) {\n                  each$1(listeners[name]);\n              }\n          }\n          else if (ns) {\n              each$2(listeners, each$1);\n          }\n          return !result;\n      };\n      return Emitter;\n  }());\n  /**\n   * 把事件类型解析成命名空间格式\n   *\n   * @param ns\n   * @param type\n   */\n  function parseNamespace(ns, type) {\n      var result = {\n          name: type,\n          ns: EMPTY_STRING\n      };\n      if (ns) {\n          var index = indexOf$1(type, '.');\n          if (index >= 0) {\n              result.name = slice(type, 0, index);\n              result.ns = slice(type, index + 1);\n          }\n      }\n      return result;\n  }\n  function matchTrue(options) {\n      return TRUE;\n  }\n  /**\n   * 外部会传入 Function 或 EmitterOptions 或 空\n   *\n   * 这里根据传入值的不同类型，创建不同的判断函数\n   *\n   * 如果传入的是 EmitterOptions，则全等判断\n   *\n   * 如果传入的是 Function，则判断函数是否全等\n   *\n   * 如果传入的是空，则直接返回 true\n   *\n   * @param listener\n   */\n  function createMatchListener(listener) {\n      return func(listener)\n          ? function (options) {\n              return listener === options.fn;\n          }\n          : matchTrue;\n  }\n  /**\n   * 判断 options 是否能匹配命名空间\n   *\n   * 如果 namespace 和 options.ns 都不为空，则需完全匹配\n   *\n   * 如果他们两个其中任何一个为空，则不判断命名空间\n   *\n   * @param namespace\n   * @param options\n   */\n  function matchNamespace(namespace, options) {\n      var ns = options.ns;\n      return ns && namespace\n          ? ns === namespace\n          : TRUE;\n  }\n\n  function isNative (target) {\n      return func(target) && /native code/.test(toString(target));\n  }\n\n  var nextTick;\n  // IE (10+) 和 node\n  if (typeof setImmediate === RAW_FUNCTION && isNative(setImmediate)) {\n      nextTick = setImmediate;\n  }\n  // 用 MessageChannel 去做 setImmediate 的 polyfill\n  // 原理是将新的 message 事件加入到原有的 dom events 之后\n  // 兼容性 IE10+ 和其他标准浏览器\n  if (typeof MessageChannel === RAW_FUNCTION && isNative(MessageChannel)) {\n      nextTick = function (fn) {\n          var channel = new MessageChannel();\n          channel.port1.onmessage = fn;\n          channel.port2.postMessage(1);\n      };\n  }\n  else {\n      nextTick = setTimeout;\n  }\n  var nextTick$1 = nextTick;\n\n  var shared;\n  var NextTask = /** @class */ (function () {\n      function NextTask() {\n          this.tasks = [];\n      }\n      /**\n       * 全局单例\n       */\n      NextTask.shared = function () {\n          return shared || (shared = new NextTask());\n      };\n      /**\n       * 在队尾添加异步任务\n       */\n      NextTask.prototype.append = function (func, context) {\n          var instance = this, tasks = instance.tasks;\n          push(tasks, {\n              fn: func,\n              ctx: context\n          });\n          if (tasks.length === 1) {\n              nextTick$1(function () {\n                  instance.run();\n              });\n          }\n      };\n      /**\n       * 在队首添加异步任务\n       */\n      NextTask.prototype.prepend = function (func, context) {\n          var instance = this, tasks = instance.tasks;\n          unshift(tasks, {\n              fn: func,\n              ctx: context\n          });\n          if (tasks.length === 1) {\n              nextTick$1(function () {\n                  instance.run();\n              });\n          }\n      };\n      /**\n       * 清空异步队列\n       */\n      NextTask.prototype.clear = function () {\n          this.tasks.length = 0;\n      };\n      /**\n       * 立即执行异步任务，并清空队列\n       */\n      NextTask.prototype.run = function () {\n          var tasks = this.tasks;\n          if (tasks.length) {\n              this.tasks = [];\n              each(tasks, function (task) {\n                  execute(task.fn, task.ctx);\n              });\n          }\n      };\n      return NextTask;\n  }());\n\n  var SYNTAX_IF = '#if';\n  var SYNTAX_ELSE = 'else';\n  var SYNTAX_ELSE_IF = 'else if';\n  var SYNTAX_EACH = '#each';\n  var SYNTAX_PARTIAL = '#partial';\n  var SYNTAX_IMPORT = '>';\n  var SYNTAX_SPREAD = '...';\n  var SYNTAX_COMMENT = /^!\\s/;\n  var SLOT_DATA_PREFIX = '$slot_';\n  var SLOT_NAME_DEFAULT = 'children';\n  var HINT_STRING = 1;\n  var HINT_NUMBER = 2;\n  var HINT_BOOLEAN = 3;\n  var DIRECTIVE_ON = 'on';\n  var DIRECTIVE_LAZY = 'lazy';\n  var DIRECTIVE_MODEL = 'model';\n  var DIRECTIVE_EVENT = 'event';\n  var DIRECTIVE_BINDING = 'binding';\n  var DIRECTIVE_CUSTOM = 'o';\n  var HOOK_BEFORE_CREATE = 'beforeCreate';\n  var HOOK_AFTER_CREATE = 'afterCreate';\n  var HOOK_BEFORE_MOUNT = 'beforeMount';\n  var HOOK_AFTER_MOUNT = 'afterMount';\n  var HOOK_BEFORE_UPDATE = 'beforeUpdate';\n  var HOOK_AFTER_UPDATE = 'afterUpdate';\n  var HOOK_BEFORE_DESTROY = 'beforeDestroy';\n  var HOOK_AFTER_DESTROY = 'afterDestroy';\n\n  var guid = 0;\n  function guid$1 () {\n      return ++guid;\n  }\n\n  // vnode.data 内部使用的几个字段\n  var ID = '$id';\n  var VNODE = '$vnode';\n  var LOADING = '$loading';\n  var COMPONENT = '$component';\n  var LEAVING = '$leaving';\n\n  function update(api, vnode, oldVnode) {\n      var node = vnode.node, nativeAttrs = vnode.nativeAttrs, oldNativeAttrs = oldVnode && oldVnode.nativeAttrs;\n      if (nativeAttrs || oldNativeAttrs) {\n          var newValue_1 = nativeAttrs || EMPTY_OBJECT, oldValue_1 = oldNativeAttrs || EMPTY_OBJECT;\n          each$2(newValue_1, function (attr, name) {\n              if (!oldValue_1[name]\n                  || attr.value !== oldValue_1[name].value) {\n                  api.attr(node, name, attr.value);\n              }\n          });\n          each$2(oldValue_1, function (_, name) {\n              if (!newValue_1[name]) {\n                  api.removeAttr(node, name);\n              }\n          });\n      }\n  }\n\n  function update$1(api, vnode, oldVnode) {\n      var node = vnode.node, nativeProps = vnode.nativeProps, oldNativeProps = oldVnode && oldVnode.nativeProps;\n      if (nativeProps || oldNativeProps) {\n          var newValue_1 = nativeProps || EMPTY_OBJECT, oldValue_1 = oldNativeProps || EMPTY_OBJECT;\n          each$2(newValue_1, function (prop, name) {\n              if (!oldValue_1[name]\n                  || prop.value !== oldValue_1[name].value) {\n                  api.prop(node, name, prop.value);\n              }\n          });\n          each$2(oldValue_1, function (prop, name) {\n              if (!newValue_1[name]) {\n                  api.removeProp(node, name, prop.hint);\n              }\n          });\n      }\n  }\n\n  function update$2(vnode, oldVnode) {\n      var data = vnode.data, directives = vnode.directives, oldDirectives = oldVnode && oldVnode.directives;\n      if (directives || oldDirectives) {\n          var node_1 = data[COMPONENT] || vnode.node, isKeypathChange_1 = oldVnode && vnode.keypath !== oldVnode.keypath, newValue_1 = directives || EMPTY_OBJECT, oldValue_1 = oldDirectives || EMPTY_OBJECT;\n          each$2(newValue_1, function (directive, name) {\n              var _a = directive.hooks, bind = _a.bind, unbind = _a.unbind;\n              if (!oldValue_1[name]) {\n                  bind(node_1, directive, vnode);\n              }\n              else if (directive.value !== oldValue_1[name].value\n                  || isKeypathChange_1) {\n                  if (unbind) {\n                      unbind(node_1, oldValue_1[name], oldVnode);\n                  }\n                  bind(node_1, directive, vnode);\n              }\n          });\n          each$2(oldValue_1, function (directive, name) {\n              if (!newValue_1[name]) {\n                  var unbind = directive.hooks.unbind;\n                  if (unbind) {\n                      unbind(node_1, directive, oldVnode);\n                  }\n              }\n          });\n      }\n  }\n  function remove$1(vnode) {\n      var directives = vnode.directives;\n      if (directives) {\n          var node_2 = vnode.data[COMPONENT] || vnode.node;\n          each$2(directives, function (directive) {\n              var unbind = directive.hooks.unbind;\n              if (unbind) {\n                  unbind(node_2, directive, vnode);\n              }\n          });\n      }\n  }\n\n  function update$3(vnode, oldVnode) {\n      var data = vnode.data, ref = vnode.ref, props = vnode.props, slots = vnode.slots, context = vnode.context, node;\n      if (vnode.isComponent) {\n          node = data[COMPONENT];\n          // 更新时才要 set\n          // 因为初始化时，所有这些都经过构造函数完成了\n          if (oldVnode) {\n              if (props) {\n                  node.set(node.checkPropTypes(props));\n              }\n              if (slots) {\n                  node.set(slots);\n              }\n          }\n      }\n      else {\n          node = vnode.node;\n      }\n      if (ref) {\n          var refs = context.$refs;\n          if (refs) {\n              refs[ref] = node;\n          }\n      }\n  }\n\n  function isPatchable(vnode, oldVnode) {\n      return vnode.tag === oldVnode.tag\n          && vnode.key === oldVnode.key;\n  }\n  function createKeyToIndex(vnodes, startIndex, endIndex) {\n      var result, vnode, key;\n      while (startIndex <= endIndex) {\n          vnode = vnodes[startIndex];\n          if (vnode && (key = vnode.key)) {\n              if (!result) {\n                  result = {};\n              }\n              result[key] = startIndex;\n          }\n          startIndex++;\n      }\n      return result || EMPTY_OBJECT;\n  }\n  function insertBefore(api, parentNode, node, referenceNode) {\n      if (referenceNode) {\n          api.before(parentNode, node, referenceNode);\n      }\n      else {\n          api.append(parentNode, node);\n      }\n  }\n  function createComponent(vnode, options) {\n      var child = (vnode.parent || vnode.context).createComponent(options, vnode);\n      vnode.data[COMPONENT] = child;\n      vnode.data[LOADING] = FALSE;\n      update$3(vnode);\n      update$2(vnode);\n      return child;\n  }\n  function createData() {\n      var data = {};\n      data[ID] = guid$1();\n      return data;\n  }\n  function createVnode(api, vnode) {\n      var tag = vnode.tag, node = vnode.node, data = vnode.data, isComponent = vnode.isComponent, isComment = vnode.isComment, isText = vnode.isText, isStyle = vnode.isStyle, children = vnode.children, text = vnode.text, html = vnode.html, context = vnode.context;\n      if (node && data) {\n          return;\n      }\n      data = createData();\n      vnode.data = data;\n      if (isText) {\n          vnode.node = api.createText(text);\n          return;\n      }\n      if (isComment) {\n          vnode.node = api.createComment(text);\n          return;\n      }\n      if (isComponent) {\n          var componentOptions_1 = UNDEFINED;\n          context.loadComponent(tag, function (options) {\n              if (has$2(data, LOADING)) {\n                  // 异步组件\n                  if (data[LOADING]) {\n                      // 尝试使用最新的 vnode\n                      if (data[VNODE]) {\n                          vnode = data[VNODE];\n                          // 用完就删掉\n                          delete data[VNODE];\n                      }\n                      enterVnode(vnode, createComponent(vnode, options));\n                  }\n              }\n              // 同步组件\n              else {\n                  componentOptions_1 = options;\n              }\n          });\n          // 不论是同步还是异步组件，都需要一个占位元素\n          vnode.node = api.createComment(RAW_COMPONENT);\n          if (componentOptions_1) {\n              createComponent(vnode, componentOptions_1);\n          }\n          else {\n              data[LOADING] = TRUE;\n          }\n      }\n      else {\n          node = vnode.node = api.createElement(vnode.tag, vnode.isSvg);\n          if (children) {\n              addVnodes(api, node, children);\n          }\n          else if (text) {\n              api.text(node, text, isStyle);\n          }\n          else if (html) {\n              api.html(node, html, isStyle);\n          }\n          update(api, vnode);\n          update$1(api, vnode);\n          update$3(vnode);\n          update$2(vnode);\n      }\n  }\n  function addVnodes(api, parentNode, vnodes, startIndex, endIndex, before) {\n      var vnode, start = startIndex || 0, end = isDef(endIndex) ? endIndex : vnodes.length - 1;\n      while (start <= end) {\n          vnode = vnodes[start];\n          createVnode(api, vnode);\n          insertVnode(api, parentNode, vnode, before);\n          start++;\n      }\n  }\n  function insertVnode(api, parentNode, vnode, before) {\n      var node = vnode.node, data = vnode.data, context = vnode.context, hasParent = api.parent(node);\n      // 这里不调用 insertBefore，避免判断两次\n      if (before) {\n          api.before(parentNode, node, before.node);\n      }\n      else {\n          api.append(parentNode, node);\n      }\n      // 普通元素和组件的占位节点都会走到这里\n      // 但是占位节点不用 enter，而是等组件加载回来之后再调 enter\n      if (!hasParent) {\n          var enter = UNDEFINED;\n          if (vnode.isComponent) {\n              var component_1 = data[COMPONENT];\n              if (component_1) {\n                  enter = function () {\n                      enterVnode(vnode, component_1);\n                  };\n              }\n          }\n          else if (!vnode.isStatic && !vnode.isText && !vnode.isComment) {\n              enter = function () {\n                  enterVnode(vnode);\n              };\n          }\n          if (enter) {\n              // 执行到这时，组件还没有挂载到 DOM 树\n              // 如果此时直接触发 enter，外部还需要做多余的工作，比如 setTimeout\n              // 索性这里直接等挂载到 DOM 数之后再触发\n              context.$observer.nextTask.prepend(enter);\n          }\n      }\n  }\n  function removeVnodes(api, parentNode, vnodes, startIndex, endIndex) {\n      var vnode, start = startIndex || 0, end = isDef(endIndex) ? endIndex : vnodes.length - 1;\n      while (start <= end) {\n          vnode = vnodes[start];\n          if (vnode) {\n              removeVnode(api, parentNode, vnode);\n          }\n          start++;\n      }\n  }\n  function removeVnode(api, parentNode, vnode) {\n      var node = vnode.node;\n      if (vnode.isStatic || vnode.isText || vnode.isComment) {\n          api.remove(parentNode, node);\n      }\n      else {\n          var done = function () {\n              destroyVnode(api, vnode);\n              api.remove(parentNode, node);\n          }, component_2;\n          if (vnode.isComponent) {\n              component_2 = vnode.data[COMPONENT];\n              // 异步组件，还没加载成功就被删除了\n              if (!component_2) {\n                  done();\n                  return;\n              }\n          }\n          leaveVnode(vnode, component_2, done);\n      }\n  }\n  function destroyVnode(api, vnode) {\n      /**\n       * 如果一个子组件的模板是这样写的：\n       *\n       * <div>\n       *   {{#if visible}}\n       *      <slot name=\"children\"/>\n       *   {{/if}}\n       * </div>\n       *\n       * 当 visible 从 true 变为 false 时，不能销毁 slot 导入的任何 vnode\n       * 不论是组件或是元素，都不能销毁，只能简单的 remove，\n       * 否则子组件下一次展现它们时，会出问题\n       */\n      var data = vnode.data, children = vnode.children, parent = vnode.parent, slot = vnode.slot;\n      // 销毁插槽组件\n      // 如果宿主组件正在销毁，$vnode 属性会在调 destroy() 之前被删除\n      // 这里表示的是宿主组件还没被销毁\n      // 如果宿主组件被销毁了，则它的一切都要进行销毁\n      if (slot && parent && parent.$vnode) {\n          // 如果更新时，父组件没有传入该 slot，则子组件需要销毁该 slot\n          var slots = parent.get(slot);\n          // slots 要么没有，要么是数组，不可能是别的\n          if (slots && has(slots, vnode)) {\n              return;\n          }\n      }\n      if (vnode.isComponent) {\n          var component_3 = data[COMPONENT];\n          if (component_3) {\n              remove$1(vnode);\n              component_3.destroy();\n          }\n          else\n              { [\n                  data[LOADING] = FALSE\n              ]; }\n      }\n      else {\n          remove$1(vnode);\n          if (children) {\n              each(children, function (child) {\n                  destroyVnode(api, child);\n              });\n          }\n      }\n  }\n  /**\n   * vnode 触发 enter hook 时，外部一般会做一些淡入动画\n   */\n  function enterVnode(vnode, component) {\n      // 如果组件根元素和组件本身都写了 transition\n      // 优先用外面定义的\n      // 因为这明确是在覆盖配置\n      var data = vnode.data, transition = vnode.transition;\n      if (component && !transition) {\n          // 再看组件根元素是否有 transition\n          transition = component.$vnode.transition;\n      }\n      execute(data[LEAVING]);\n      if (transition) {\n          var enter = transition.enter;\n          if (enter) {\n              enter(vnode.node);\n              return;\n          }\n      }\n  }\n  /**\n   * vnode 触发 leave hook 时，外部一般会做一些淡出动画\n   * 动画结束后才能移除节点，否则无法产生动画\n   * 这里由外部调用 done 来通知内部动画结束\n   */\n  function leaveVnode(vnode, component, done) {\n      // 如果组件根元素和组件本身都写了 transition\n      // 优先用外面定义的\n      // 因为这明确是在覆盖配置\n      var data = vnode.data, transition = vnode.transition;\n      if (component && !transition) {\n          // 再看组件根元素是否有 transition\n          transition = component.$vnode.transition;\n      }\n      if (transition) {\n          var leave = transition.leave;\n          if (leave) {\n              leave(vnode.node, data[LEAVING] = function () {\n                  if (data[LEAVING]) {\n                      done();\n                      data[LEAVING] = UNDEFINED;\n                  }\n              });\n              return;\n          }\n      }\n      // 如果没有淡出动画，直接结束\n      done();\n  }\n  function updateChildren(api, parentNode, children, oldChildren) {\n      var startIndex = 0, endIndex = children.length - 1, startVnode = children[startIndex], endVnode = children[endIndex], oldStartIndex = 0, oldEndIndex = oldChildren.length - 1, oldStartVnode = oldChildren[oldStartIndex], oldEndVnode = oldChildren[oldEndIndex], oldKeyToIndex, oldIndex;\n      while (oldStartIndex <= oldEndIndex && startIndex <= endIndex) {\n          // 下面有设为 UNDEFINED 的逻辑\n          if (!startVnode) {\n              startVnode = children[++startIndex];\n          }\n          else if (!endVnode) {\n              endVnode = children[--endIndex];\n          }\n          else if (!oldStartVnode) {\n              oldStartVnode = oldChildren[++oldStartIndex];\n          }\n          else if (!oldEndVnode) {\n              oldEndVnode = oldChildren[--oldEndIndex];\n          }\n          // 从头到尾比较，位置相同且值得 patch\n          else if (isPatchable(startVnode, oldStartVnode)) {\n              patch(api, startVnode, oldStartVnode);\n              startVnode = children[++startIndex];\n              oldStartVnode = oldChildren[++oldStartIndex];\n          }\n          // 从尾到头比较，位置相同且值得 patch\n          else if (isPatchable(endVnode, oldEndVnode)) {\n              patch(api, endVnode, oldEndVnode);\n              endVnode = children[--endIndex];\n              oldEndVnode = oldChildren[--oldEndIndex];\n          }\n          // 比较完两侧的节点，剩下就是 位置发生改变的节点 和 全新的节点\n          // 当 endVnode 和 oldStartVnode 值得 patch\n          // 说明元素被移到右边了\n          else if (isPatchable(endVnode, oldStartVnode)) {\n              patch(api, endVnode, oldStartVnode);\n              insertBefore(api, parentNode, oldStartVnode.node, api.next(oldEndVnode.node));\n              endVnode = children[--endIndex];\n              oldStartVnode = oldChildren[++oldStartIndex];\n          }\n          // 当 oldEndVnode 和 startVnode 值得 patch\n          // 说明元素被移到左边了\n          else if (isPatchable(startVnode, oldEndVnode)) {\n              patch(api, startVnode, oldEndVnode);\n              insertBefore(api, parentNode, oldEndVnode.node, oldStartVnode.node);\n              startVnode = children[++startIndex];\n              oldEndVnode = oldChildren[--oldEndIndex];\n          }\n          // 尝试同级元素的 key\n          else {\n              if (!oldKeyToIndex) {\n                  oldKeyToIndex = createKeyToIndex(oldChildren, oldStartIndex, oldEndIndex);\n              }\n              // 新节点之前的位置\n              oldIndex = startVnode.key\n                  ? oldKeyToIndex[startVnode.key]\n                  : UNDEFINED;\n              // 移动元素\n              if (isDef(oldIndex)) {\n                  patch(api, startVnode, oldChildren[oldIndex]);\n                  oldChildren[oldIndex] = UNDEFINED;\n              }\n              // 新元素\n              else {\n                  createVnode(api, startVnode);\n              }\n              insertVnode(api, parentNode, startVnode, oldStartVnode);\n              startVnode = children[++startIndex];\n          }\n      }\n      if (oldStartIndex > oldEndIndex) {\n          addVnodes(api, parentNode, children, startIndex, endIndex, children[endIndex + 1]);\n      }\n      else if (startIndex > endIndex) {\n          removeVnodes(api, parentNode, oldChildren, oldStartIndex, oldEndIndex);\n      }\n  }\n  function patch(api, vnode, oldVnode) {\n      if (vnode === oldVnode) {\n          return;\n      }\n      var node = oldVnode.node, data = oldVnode.data;\n      // 如果不能 patch，则删除重建\n      if (!isPatchable(vnode, oldVnode)) {\n          // 同步加载的组件，初始化时不会传入占位节点\n          // 它内部会自动生成一个注释节点，当它的根 vnode 和注释节点对比时，必然无法 patch\n          // 于是走进此分支，为新组件创建一个 DOM 节点，然后继续 createComponent 后面的流程\n          var parentNode = api.parent(node);\n          createVnode(api, vnode);\n          if (parentNode) {\n              insertVnode(api, parentNode, vnode, oldVnode);\n              removeVnode(api, parentNode, oldVnode);\n          }\n          return;\n      }\n      vnode.node = node;\n      vnode.data = data;\n      // 组件正在异步加载，更新为最新的 vnode\n      // 当异步加载完成时才能用上最新的 vnode\n      if (oldVnode.isComponent && data[LOADING]) {\n          data[VNODE] = vnode;\n          return;\n      }\n      // 两棵静态子树就别折腾了\n      if (vnode.isStatic && oldVnode.isStatic) {\n          return;\n      }\n      update(api, vnode, oldVnode);\n      update$1(api, vnode, oldVnode);\n      update$3(vnode, oldVnode);\n      update$2(vnode, oldVnode);\n      var text = vnode.text, html = vnode.html, children = vnode.children, isStyle = vnode.isStyle, oldText = oldVnode.text, oldHtml = oldVnode.html, oldChildren = oldVnode.children;\n      if (string(text)) {\n          if (text !== oldText) {\n              api.text(node, text, isStyle);\n          }\n      }\n      else if (string(html)) {\n          if (html !== oldHtml) {\n              api.html(node, html, isStyle);\n          }\n      }\n      // 两个都有需要 diff\n      else if (children && oldChildren) {\n          if (children !== oldChildren) {\n              updateChildren(api, node, children, oldChildren);\n          }\n      }\n      // 有新的没旧的 - 新增节点\n      else if (children) {\n          if (string(oldText) || string(oldHtml)) {\n              api.text(node, EMPTY_STRING, isStyle);\n          }\n          addVnodes(api, node, children);\n      }\n      // 有旧的没新的 - 删除节点\n      else if (oldChildren) {\n          removeVnodes(api, node, oldChildren);\n      }\n      // 有旧的 text 没有新的 text\n      else if (string(oldText) || string(oldHtml)) {\n          api.text(node, EMPTY_STRING, isStyle);\n      }\n  }\n  function create(api, node, context, keypath) {\n      return {\n          tag: api.tag(node),\n          data: createData(),\n          node: node,\n          context: context,\n          keypath: keypath\n      };\n  }\n  function destroy(api, vnode, isRemove) {\n      if (isRemove) {\n          var parentNode = api.parent(vnode.node);\n          if (parentNode) {\n              removeVnode(api, parentNode, vnode);\n          }\n          else {\n              fatal(\"Can't destroy vnode without parent node.\");\n          }\n      }\n      else {\n          destroyVnode(api, vnode);\n      }\n  }\n\n  function toNumber (target, defaultValue) {\n      return numeric(target)\n          ? +target\n          : isDef(defaultValue)\n              ? defaultValue\n              : 0;\n  }\n\n  /**\n   * 字面量\n   */\n  var LITERAL = 1;\n  /**\n   * 标识符\n   */\n  var IDENTIFIER = 2;\n  /**\n   * 对象属性或数组下标\n   */\n  var MEMBER = 3;\n  /**\n   * 一元表达式，如 - a\n   */\n  var UNARY = 4;\n  /**\n   * 二元表达式，如 a + b\n   */\n  var BINARY = 5;\n  /**\n   * 三元表达式，如 a ? b : c\n   */\n  var TERNARY = 6;\n  /**\n   * 数组表达式，如 [ 1, 2, 3 ]\n   */\n  var ARRAY = 7;\n  /**\n   * 对象表达式，如 { name: 'yox' }\n   */\n  var OBJECT = 8;\n  /**\n   * 函数调用表达式，如 a()\n   */\n  var CALL = 9;\n\n  function createArray(nodes, raw) {\n      return {\n          type: ARRAY,\n          raw: raw,\n          nodes: nodes\n      };\n  }\n  function createBinary(a, op, b, raw) {\n      return {\n          type: BINARY,\n          raw: raw,\n          a: a,\n          op: op,\n          b: b\n      };\n  }\n  function createCall(name, args, raw) {\n      return {\n          type: CALL,\n          raw: raw,\n          name: name,\n          args: args\n      };\n  }\n  function createIdentifierInner(raw, name, lookup, offset, sk) {\n      return {\n          type: IDENTIFIER,\n          raw: raw,\n          name: name,\n          lookup: lookup === FALSE ? lookup : UNDEFINED,\n          offset: offset > 0 ? offset : UNDEFINED,\n          sk: isDef(sk) ? sk : name\n      };\n  }\n  function createMemberInner(raw, props, lookup, offset, sk) {\n      return {\n          type: MEMBER,\n          raw: raw,\n          props: props,\n          lookup: lookup === FALSE ? lookup : UNDEFINED,\n          offset: offset > 0 ? offset : UNDEFINED,\n          sk: sk\n      };\n  }\n  function createIdentifier(raw, name, isProp) {\n      var lookup, offset;\n      if (name === KEYPATH_CURRENT\n          || name === KEYPATH_PARENT) {\n          lookup = FALSE;\n          if (name === KEYPATH_PARENT) {\n              offset = 1;\n          }\n          name = EMPTY_STRING;\n      }\n      // 对象属性需要区分 a.b 和 a[b]\n      // 如果不借用 Literal 无法实现这个判断\n      // 同理，如果用了这种方式，就无法区分 a.b 和 a['b']，但是无所谓，这两种表示法本就一个意思\n      return isProp\n          ? createLiteral(name, raw)\n          : createIdentifierInner(raw, name, lookup, offset);\n  }\n  function createLiteral(value, raw) {\n      return {\n          type: LITERAL,\n          raw: raw,\n          value: value\n      };\n  }\n  function createObject(keys, values, raw) {\n      return {\n          type: OBJECT,\n          raw: raw,\n          keys: keys,\n          values: values\n      };\n  }\n  function createTernary(test, yes, no, raw) {\n      return {\n          type: TERNARY,\n          raw: raw,\n          test: test,\n          yes: yes,\n          no: no\n      };\n  }\n  function createUnary(op, a, raw) {\n      return {\n          type: UNARY,\n          raw: raw,\n          op: op,\n          a: a\n      };\n  }\n  function getLiteralNode(nodes, index) {\n      if (nodes[index]\n          && nodes[index].type === LITERAL) {\n          return nodes[index];\n      }\n  }\n  /**\n   * 通过判断 nodes 来决定是否需要创建 Member\n   *\n   * 创建 Member 至少需要 nodes 有两个元素\n   *\n   * nodes 元素类型没有限制，可以是 Identifier、Literal、Call，或是别的完整表达式\n   *\n   * @param raw\n   * @param nodes\n   */\n  function createMemberIfNeeded(raw, nodes) {\n      var length = nodes.length, lookup, offset = 0, staticKeypath, name = EMPTY_STRING, list = [], literal, identifier;\n      if (length > 1) {\n          // lookup 要求第一位元素是 Identifier，且它的 lookup 是 true 才为 true\n          // 其他情况都为 false，如 \"11\".length 第一位元素是 Literal，不存在向上寻找的需求\n          if (nodes[0].type === IDENTIFIER) {\n              identifier = nodes[0];\n              name = identifier.name;\n              lookup = identifier.lookup;\n              staticKeypath = identifier.sk;\n              if (identifier.offset > 0) {\n                  offset += identifier.offset;\n              }\n              if (name) {\n                  push(list, identifier);\n              }\n              // 优化 1：计算 staticKeypath\n              //\n              // 计算 staticKeypath 的唯一方式是，第一位元素是 Identifier，后面都是 Literal\n              // 否则就表示中间包含动态元素，这会导致无法计算静态路径\n              // 如 a.b.c 可以算出 staticKeypath，而 a[b].c 则不行，因为 b 是动态的\n              // 下面这段属于性能优化，避免在运行时反复计算 Member 的 keypath\n              // 优化 2：计算 offset 并智能转成 Identifier\n              //\n              // 比如 ../../xx 这样的表达式，应优化成 offset = 2，并转成 Identifier\n              for (var i = 1; i < length; i++) {\n                  literal = getLiteralNode(nodes, i);\n                  if (literal) {\n                      if (literal.raw === KEYPATH_PARENT) {\n                          offset += 1;\n                          continue;\n                      }\n                      if (isDef(staticKeypath)\n                          && literal.raw !== KEYPATH_CURRENT) {\n                          staticKeypath = join$1(staticKeypath, toString(literal.value));\n                      }\n                  }\n                  else {\n                      staticKeypath = UNDEFINED;\n                  }\n                  push(list, nodes[i]);\n              }\n              // 表示 nodes 中包含路径，并且路径节点被干掉了\n              if (list.length < length) {\n                  nodes = list;\n                  // 剩下的节点，第一个如果是 Literal，把它转成 Identifier\n                  literal = getLiteralNode(nodes, 0);\n                  if (literal) {\n                      name = literal.value;\n                      nodes[0] = createIdentifierInner(literal.raw, name, lookup, offset);\n                  }\n              }\n          }\n          // 如果全是路径节点，如 ../../this，nodes 为空数组\n          // 如果剩下一个节点，则可转成标识符\n          return nodes.length < 2\n              ? createIdentifierInner(raw, name, lookup, offset, staticKeypath)\n              : createMemberInner(raw, nodes, lookup, offset, staticKeypath);\n      }\n      return nodes[0];\n  }\n\n  var unary = {\n      '+': { exec: function (a) { return +a; } },\n      '-': { exec: function (a) { return -a; } },\n      '~': { exec: function (a) { return ~a; } },\n      '!': { exec: function (a) { return !a; } },\n      '!!': { exec: function (a) { return !!a; } }\n  };\n  // 参考 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\n  var binary = {\n      '*': { prec: 14, exec: function (a, b) { return a * b; } },\n      '/': { prec: 14, exec: function (a, b) { return a / b; } },\n      '%': { prec: 14, exec: function (a, b) { return a % b; } },\n      '+': { prec: 13, exec: function (a, b) { return a + b; } },\n      '-': { prec: 13, exec: function (a, b) { return a - b; } },\n      '<<': { prec: 12, exec: function (a, b) { return a << b; } },\n      '>>': { prec: 12, exec: function (a, b) { return a >> b; } },\n      '>>>': { prec: 12, exec: function (a, b) { return a >>> b; } },\n      '<': { prec: 11, exec: function (a, b) { return a < b; } },\n      '<=': { prec: 11, exec: function (a, b) { return a <= b; } },\n      '>': { prec: 11, exec: function (a, b) { return a > b; } },\n      '>=': { prec: 11, exec: function (a, b) { return a >= b; } },\n      '==': { prec: 10, exec: function (a, b) { return a == b; } },\n      '!=': { prec: 10, exec: function (a, b) { return a != b; } },\n      '===': { prec: 10, exec: function (a, b) { return a === b; } },\n      '!==': { prec: 10, exec: function (a, b) { return a !== b; } },\n      '&': { prec: 9, exec: function (a, b) { return a & b; } },\n      '^': { prec: 8, exec: function (a, b) { return a ^ b; } },\n      '|': { prec: 7, exec: function (a, b) { return a | b; } },\n      '&&': { prec: 6, exec: function (a, b) { return a && b; } },\n      '||': { prec: 5, exec: function (a, b) { return a || b; } },\n      '->': {\n          prec: 0,\n          exec: function (a, b) {\n              return a > b\n                  ? function (callback) {\n                      for (var i = a, index = 0; i > b; i--) {\n                          callback(i, index++);\n                      }\n                  }\n                  : function (callback) {\n                      for (var i = a, index = 0; i < b; i++) {\n                          callback(i, index++);\n                      }\n                  };\n          }\n      },\n      '=>': {\n          prec: 0,\n          exec: function (a, b) {\n              return a > b\n                  ? function (callback) {\n                      for (var i = a, index = 0; i >= b; i--) {\n                          callback(i, index++);\n                      }\n                  }\n                  : function (callback) {\n                      for (var i = a, index = 0; i <= b; i++) {\n                          callback(i, index++);\n                      }\n                  };\n          }\n      }\n  };\n\n  function compile(content) {\n      if (!cache[content]) {\n          var parser = new Parser(content);\n          cache[content] = parser.scanTernary(CODE_EOF);\n      }\n      return cache[content];\n  }\n  var Parser = /** @class */ (function () {\n      function Parser(content) {\n          var instance = this, length = content.length;\n          instance.index = -1;\n          instance.end = length;\n          instance.code = CODE_EOF;\n          instance.content = content;\n          instance.go();\n      }\n      /**\n       * 移动一个字符\n       */\n      Parser.prototype.go = function (step) {\n          var instance = this, index = instance.index, end = instance.end;\n          index += step || 1;\n          if (index >= 0 && index < end) {\n              instance.code = codeAt(instance.content, index);\n              instance.index = index;\n          }\n          else {\n              instance.code = CODE_EOF;\n              instance.index = index < 0 ? -1 : end;\n          }\n      };\n      /**\n       * 跳过空白符\n       */\n      Parser.prototype.skip = function (step) {\n          var instance = this;\n          // 走一步\n          if (instance.code === CODE_EOF) {\n              instance.go(step);\n          }\n          // 如果是正向的，停在第一个非空白符左侧\n          // 如果是逆向的，停在第一个非空白符右侧\n          while (TRUE) {\n              if (isWhitespace(instance.code)) {\n                  instance.go(step);\n              }\n              else {\n                  if (step && step < 0) {\n                      instance.go();\n                  }\n                  break;\n              }\n          }\n      };\n      /**\n       * 判断当前字符\n       */\n      Parser.prototype.is = function (code) {\n          return this.code === code;\n      };\n      /**\n       * 截取一段字符串\n       *\n       * @param startIndex\n       */\n      Parser.prototype.pick = function (startIndex, endIndex) {\n          return slice(this.content, startIndex, isDef(endIndex) ? endIndex : this.index);\n      };\n      /**\n       * 尝试解析下一个 token\n       */\n      Parser.prototype.scanToken = function () {\n          var instance = this, code = instance.code, index = instance.index;\n          if (isIdentifierStart(code)) {\n              return instance.scanTail(index, [\n                  instance.scanIdentifier(index)\n              ]);\n          }\n          if (isDigit(code)) {\n              return instance.scanNumber(index);\n          }\n          switch (code) {\n              case CODE_EOF:\n                  return;\n              // 'x' \"x\"\n              case CODE_SQUOTE:\n              case CODE_DQUOTE:\n                  return instance.scanTail(index, [\n                      instance.scanString(index, code)\n                  ]);\n              // .1  ./  ../\n              case CODE_DOT:\n                  instance.go();\n                  return isDigit(instance.code)\n                      ? instance.scanNumber(index)\n                      : instance.scanPath(index);\n              // (xx)\n              case CODE_OPAREN:\n                  instance.go();\n                  return instance.scanTernary(CODE_CPAREN);\n              // [xx, xx]\n              case CODE_OBRACK:\n                  return instance.scanTail(index, [\n                      createArray(instance.scanTuple(index, CODE_CBRACK), instance.pick(index))\n                  ]);\n              // { a: 'x', b: 'x' }\n              case CODE_OBRACE:\n                  return instance.scanObject(index);\n          }\n          // 因为 scanOperator 会导致 index 发生变化，只能放在最后尝试\n          var operator = instance.scanOperator(index);\n          if (operator && unary[operator]) {\n              var node = instance.scanTernary();\n              if (node) {\n                  if (node.type === LITERAL) {\n                      var value = node.value;\n                      if (number(value)) {\n                          // 类似 ' -1 ' 这样的右侧有空格，需要撤回来\n                          instance.skip(-1);\n                          return createLiteral(-value, instance.pick(index));\n                      }\n                  }\n                  // 类似 ' -a ' 这样的右侧有空格，需要撤回来\n                  instance.skip(-1);\n                  return createUnary(operator, node, instance.pick(index));\n              }\n              {\n                  instance.fatal(index, \"\\u4E00\\u5143\\u8FD0\\u7B97\\u53EA\\u6709\\u64CD\\u4F5C\\u7B26\\u6CA1\\u6709\\u8868\\u8FBE\\u5F0F\\uFF1F\");\n              }\n          }\n      };\n      /**\n       * 扫描数字\n       *\n       * 支持整数和小数\n       *\n       * @param startIndex\n       * @return\n       */\n      Parser.prototype.scanNumber = function (startIndex) {\n          var instance = this;\n          while (isNumber(instance.code)) {\n              instance.go();\n          }\n          var raw = instance.pick(startIndex);\n          // 尝试转型，如果转型失败，则确定是个错误的数字\n          if (numeric(raw)) {\n              return createLiteral(+raw, raw);\n          }\n          {\n              instance.fatal(startIndex, \"\\u6570\\u5B57\\u5199\\u9519\\u4E86\\u77E5\\u9053\\u5417\\uFF1F\");\n          }\n      };\n      /**\n       * 扫描字符串\n       *\n       * 支持反斜线转义引号\n       *\n       * @param startIndex\n       * @param endCode\n       */\n      Parser.prototype.scanString = function (startIndex, endCode) {\n          var instance = this;\n          loop: while (TRUE) {\n              // 这句有两个作用：\n              // 1. 跳过开始的引号\n              // 2. 驱动 index 前进\n              instance.go();\n              switch (instance.code) {\n                  // \\\" \\'\n                  case CODE_BACKSLASH:\n                      instance.go();\n                      break;\n                  case endCode:\n                      instance.go();\n                      break loop;\n                  case CODE_EOF:\n                      {\n                          instance.fatal(startIndex, \"\\u5230\\u5934\\u4E86\\uFF0C\\u5B57\\u7B26\\u4E32\\u8FD8\\u6CA1\\u89E3\\u6790\\u5B8C\\u5462\\uFF1F\");\n                      }\n                      break loop;\n              }\n          }\n          // new Function 处理字符转义\n          var raw = instance.pick(startIndex);\n          return createLiteral(new Function(\"return \" + raw)(), raw);\n      };\n      /**\n       * 扫描对象字面量\n       *\n       * @param startIndex\n       */\n      Parser.prototype.scanObject = function (startIndex) {\n          var instance = this, keys = [], values = [], isKey = TRUE, node;\n          // 跳过 {\n          instance.go();\n          loop: while (TRUE) {\n              switch (instance.code) {\n                  case CODE_CBRACE:\n                      instance.go();\n                      {\n                          if (keys.length !== values.length) {\n                              instance.fatal(startIndex, \"\\u5BF9\\u8C61\\u7684 keys \\u548C values \\u7684\\u957F\\u5EA6\\u4E0D\\u4E00\\u81F4\");\n                          }\n                      }\n                      break loop;\n                  case CODE_EOF:\n                      {\n                          instance.fatal(startIndex, \"\\u5230\\u5934\\u4E86\\uFF0C\\u5BF9\\u8C61\\u8FD8\\u6CA1\\u89E3\\u6790\\u5B8C\\u5462\\uFF1F\");\n                      }\n                      break loop;\n                  // :\n                  case CODE_COLON:\n                      instance.go();\n                      isKey = FALSE;\n                      break;\n                  // ,\n                  case CODE_COMMA:\n                      instance.go();\n                      isKey = TRUE;\n                      break;\n                  default:\n                      // 解析 key 的时候，node 可以为空，如 { } 或 { name: 'xx', }\n                      // 解析 value 的时候，node 不能为空\n                      node = instance.scanTernary();\n                      if (isKey) {\n                          if (node) {\n                              // 处理 { key : value } key 后面的空格\n                              instance.skip();\n                              if (node.type === IDENTIFIER) {\n                                  push(keys, node.name);\n                              }\n                              else if (node.type === LITERAL) {\n                                  push(keys, node.value);\n                              }\n                              else {\n                                  {\n                                      instance.fatal(startIndex, \"\\u5BF9\\u8C61\\u7684 key \\u5FC5\\u987B\\u662F\\u5B57\\u9762\\u91CF\\u6216\\u6807\\u8BC6\\u7B26\");\n                                  }\n                                  break loop;\n                              }\n                          }\n                      }\n                      else if (node) {\n                          // 处理 { key : value } value 后面的空格\n                          instance.skip();\n                          push(values, node);\n                      }\n                      else {\n                          {\n                              instance.fatal(startIndex, \"\\u5BF9\\u8C61\\u7684\\u503C\\u6CA1\\u627E\\u5230\");\n                          }\n                          break loop;\n                      }\n              }\n          }\n          return createObject(keys, values, instance.pick(startIndex));\n      };\n      /**\n       * 扫描元组，即 `a, b, c` 这种格式，可以是参数列表，也可以是数组\n       *\n       * @param startIndex\n       * @param endCode 元组的结束字符编码\n       */\n      Parser.prototype.scanTuple = function (startIndex, endCode) {\n          var instance = this, nodes = [], node;\n          // 跳过开始字符，如 [ 和 (\n          instance.go();\n          loop: while (TRUE) {\n              switch (instance.code) {\n                  case endCode:\n                      instance.go();\n                      break loop;\n                  case CODE_EOF:\n                      {\n                          instance.fatal(startIndex, \"\\u5230\\u5934\\u4E86\\uFF0Ctuple \\u8FD8\\u6CA1\\u89E3\\u6790\\u5B8C\\u5462\\uFF1F\");\n                      }\n                      break loop;\n                  case CODE_COMMA:\n                      instance.go();\n                      break;\n                  default:\n                      // 1. ( )\n                      // 2. (1, 2, )\n                      // 这三个例子都会出现 scanTernary 为空的情况\n                      // 但是不用报错\n                      node = instance.scanTernary();\n                      if (node) {\n                          // 为了解决 1 , 2 , 3 这样的写法\n                          // 当解析出值后，先跳过后面的空格\n                          instance.skip();\n                          push(nodes, node);\n                      }\n              }\n          }\n          return nodes;\n      };\n      /**\n       * 扫描路径，如 `./` 和 `../`\n       *\n       * 路径必须位于开头，如 ./../ 或 ../../，不存在 a/../b/../c 这样的情况，因为路径是用来切换或指定 context 的\n       *\n       * @param startIndex\n       * @param prevNode\n       */\n      Parser.prototype.scanPath = function (startIndex) {\n          var instance = this, nodes = [], name;\n          // 进入此函数时，已确定前一个 code 是 CODE_DOT\n          // 此时只需判断接下来是 ./ 还是 / 就行了\n          while (TRUE) {\n              // 要么是 current 要么是 parent\n              name = KEYPATH_CURRENT;\n              // ../\n              if (instance.is(CODE_DOT)) {\n                  instance.go();\n                  name = KEYPATH_PARENT;\n              }\n              push(nodes, createIdentifier(name, name, nodes.length > 0));\n              // 如果以 / 结尾，则命中 ./ 或 ../\n              if (instance.is(CODE_SLASH)) {\n                  instance.go();\n                  // 没写错，这里不必强调 isIdentifierStart，数字开头也可以吧\n                  if (isIdentifierPart(instance.code)) {\n                      push(nodes, instance.scanIdentifier(instance.index, TRUE));\n                      return instance.scanTail(startIndex, nodes);\n                  }\n                  else if (instance.is(CODE_DOT)) {\n                      // 先跳过第一个 .\n                      instance.go();\n                      // 继续循环\n                  }\n                  else {\n                      // 类似 ./ 或 ../ 这样后面不跟标识符是想干嘛？报错可好？\n                      {\n                          instance.fatal(startIndex, \"path \\u5199\\u6CD5\\u9519\\u8BEF\");\n                      }\n                      break;\n                  }\n              }\n              // 类似 . 或 ..，可能就是想读取层级对象\n              // 此处不用关心后面跟的具体是什么字符，那是其他函数的事情，就算报错也让别的函数去报\n              // 此处也不用关心延展操作符，即 ...object，因为表达式引擎管不了这事，它没法把对象变成 attr1=value1 attr2=value2 的格式\n              // 这应该是模板引擎该做的事\n              else {\n                  break;\n              }\n          }\n      };\n      /**\n       * 扫描变量\n       */\n      Parser.prototype.scanTail = function (startIndex, nodes) {\n          var instance = this, node;\n          /**\n           * 标识符后面紧着的字符，可以是 ( . [，此外还存在各种组合，感受一下：\n           *\n           * a.b.c().length\n           * a[b].c()()\n           * a[b][c]()[d](e, f, g).length\n           * [].length\n           */\n          loop: while (TRUE) {\n              switch (instance.code) {\n                  // a(x)\n                  case CODE_OPAREN:\n                      nodes = [\n                          createCall(createMemberIfNeeded(instance.pick(startIndex), nodes), instance.scanTuple(instance.index, CODE_CPAREN), instance.pick(startIndex))\n                      ];\n                      break;\n                  // a.x\n                  case CODE_DOT:\n                      instance.go();\n                      // 接下来的字符，可能是数字，也可能是标识符，如果不是就报错\n                      if (isIdentifierPart(instance.code)) {\n                          // 无需识别关键字\n                          push(nodes, instance.scanIdentifier(instance.index, TRUE));\n                          break;\n                      }\n                      else {\n                          {\n                              instance.fatal(startIndex, \". \\u540E\\u9762\\u8DDF\\u7684\\u90FD\\u662F\\u5565\\u73A9\\u610F\\u554A\");\n                          }\n                          break loop;\n                      }\n                  // a[]\n                  case CODE_OBRACK:\n                      // 过掉 [\n                      instance.go();\n                      node = instance.scanTernary(CODE_CBRACK);\n                      if (node) {\n                          push(nodes, node);\n                          break;\n                      }\n                      else {\n                          {\n                              instance.fatal(startIndex, \"[] \\u5185\\u90E8\\u4E0D\\u80FD\\u4E3A\\u7A7A\");\n                          }\n                          break loop;\n                      }\n                  default:\n                      break loop;\n              }\n          }\n          return createMemberIfNeeded(instance.pick(startIndex), nodes);\n      };\n      /**\n       * 扫描标识符\n       *\n       * @param startIndex\n       * @param isProp 是否是对象的属性\n       * @return\n       */\n      Parser.prototype.scanIdentifier = function (startIndex, isProp) {\n          var instance = this;\n          while (isIdentifierPart(instance.code)) {\n              instance.go();\n          }\n          var raw = instance.pick(startIndex);\n          return !isProp && has$2(keywordLiterals, raw)\n              ? createLiteral(keywordLiterals[raw].value, raw)\n              : createIdentifier(raw, raw, isProp);\n      };\n      /**\n       * 扫描运算符\n       *\n       * @param startIndex\n       */\n      Parser.prototype.scanOperator = function (startIndex) {\n          var instance = this;\n          switch (instance.code) {\n              // /、%、~、^\n              case CODE_DIVIDE:\n              case CODE_MODULO:\n              case CODE_WAVE:\n              case CODE_XOR:\n                  instance.go();\n                  break;\n              // *\n              case CODE_MULTIPLY:\n                  instance.go();\n                  break;\n              // +\n              case CODE_PLUS:\n                  instance.go();\n                  {\n                      // ++\n                      if (instance.is(CODE_PLUS)) {\n                          instance.fatal(startIndex, \"\\u4E0D\\u652F\\u6301\\u8BE5\\u8BED\\u6CD5\");\n                      }\n                  }\n                  break;\n              // -、->\n              case CODE_MINUS:\n                  instance.go();\n                  if (instance.is(CODE_GREAT)) {\n                      instance.go();\n                  }\n                  else {\n                      // --\n                      if (instance.is(CODE_MINUS)) {\n                          instance.fatal(startIndex, \"\\u4E0D\\u652F\\u6301\\u8BE5\\u8BED\\u6CD5\");\n                      }\n                  }\n                  break;\n              // !、!!、!=、!==\n              case CODE_NOT:\n                  instance.go();\n                  if (instance.is(CODE_NOT)) {\n                      instance.go();\n                  }\n                  else if (instance.is(CODE_EQUAL)) {\n                      instance.go();\n                      if (instance.is(CODE_EQUAL)) {\n                          instance.go();\n                      }\n                  }\n                  break;\n              // &、&&\n              case CODE_AND:\n                  instance.go();\n                  if (instance.is(CODE_AND)) {\n                      instance.go();\n                  }\n                  break;\n              // |、||\n              case CODE_OR:\n                  instance.go();\n                  if (instance.is(CODE_OR)) {\n                      instance.go();\n                  }\n                  break;\n              // ==、===、=>\n              case CODE_EQUAL:\n                  instance.go();\n                  if (instance.is(CODE_EQUAL)) {\n                      instance.go();\n                      if (instance.is(CODE_EQUAL)) {\n                          instance.go();\n                      }\n                  }\n                  else if (instance.is(CODE_GREAT)) {\n                      instance.go();\n                  }\n                  // 一个等号要报错\n                  else {\n                      instance.fatal(startIndex, \"\\u4E0D\\u652F\\u6301\\u4E00\\u4E2A\\u7B49\\u53F7\\u8FD9\\u79CD\\u8D4B\\u503C\\u5199\\u6CD5\");\n                  }\n                  break;\n              // <、<=、<<\n              case CODE_LESS:\n                  instance.go();\n                  if (instance.is(CODE_EQUAL)\n                      || instance.is(CODE_LESS)) {\n                      instance.go();\n                  }\n                  break;\n              // >、>=、>>、>>>\n              case CODE_GREAT:\n                  instance.go();\n                  if (instance.is(CODE_EQUAL)) {\n                      instance.go();\n                  }\n                  else if (instance.is(CODE_GREAT)) {\n                      instance.go();\n                      if (instance.is(CODE_GREAT)) {\n                          instance.go();\n                      }\n                  }\n                  break;\n          }\n          if (instance.code > startIndex) {\n              return instance.pick(startIndex);\n          }\n      };\n      /**\n       * 扫描二元运算\n       */\n      Parser.prototype.scanBinary = function (startIndex) {\n          // 二元运算，如 a + b * c / d，这里涉及运算符的优先级\n          // 算法参考 https://en.wikipedia.org/wiki/Shunting-yard_algorithm\n          var instance = this, \n          // 格式为 [ index1, node1, index2, node2, ... ]\n          output = [], token, index, operator, operatorInfo, lastOperator, lastOperatorInfo;\n          while (TRUE) {\n              instance.skip();\n              push(output, instance.index);\n              token = instance.scanToken();\n              if (token) {\n                  push(output, token);\n                  push(output, instance.index);\n                  instance.skip();\n                  operator = instance.scanOperator(instance.index);\n                  // 必须是二元运算符，一元不行\n                  if (operator && (operatorInfo = binary[operator])) {\n                      // 比较前一个运算符\n                      index = output.length - 4;\n                      // 如果前一个运算符的优先级 >= 现在这个，则新建 Binary\n                      // 如 a + b * c / d，当从左到右读取到 / 时，发现和前一个 * 优先级相同，则把 b * c 取出用于创建 Binary\n                      if ((lastOperator = output[index])\n                          && (lastOperatorInfo = binary[lastOperator])\n                          && lastOperatorInfo.prec >= operatorInfo.prec) {\n                          output.splice(index - 2, 5, createBinary(output[index - 2], lastOperator, output[index + 2], instance.pick(output[index - 3], output[index + 3])));\n                      }\n                      push(output, operator);\n                      continue;\n                  }\n                  else {\n                      operator = UNDEFINED;\n                  }\n              }\n              // 比如不支持的表达式，a++ 之类的\n              else {\n                  if (operator) {\n                      instance.fatal(startIndex, '表达式错误');\n                  }\n              }\n              // 没匹配到 token 或 operator 则跳出循环\n              break;\n          }\n          // 类似 a + b * c 这种走到这会有 11 个\n          // 此时需要从后往前遍历，因为确定后面的优先级肯定大于前面的\n          while (TRUE) {\n              // 最少的情况是 a + b，它有 7 个元素\n              if (output.length >= 7) {\n                  index = output.length - 4;\n                  output.splice(index - 2, 5, createBinary(output[index - 2], output[index], output[index + 2], instance.pick(output[index - 3], output[index + 3])));\n              }\n              else {\n                  return output[1];\n              }\n          }\n      };\n      /**\n       * 扫描三元运算\n       *\n       * @param endCode\n       */\n      Parser.prototype.scanTernary = function (endCode) {\n          /**\n           * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence\n           *\n           * ?: 运算符的优先级几乎是最低的，比它低的只有四种： 赋值、yield、延展、逗号\n           * 我们不支持这四种，因此可认为 ?: 优先级最低\n           */\n          var instance = this;\n          instance.skip();\n          var index = instance.index, test = instance.scanBinary(index), yes, no;\n          if (instance.is(CODE_QUESTION)) {\n              // 跳过 ?\n              instance.go();\n              yes = instance.scanBinary(index);\n              if (instance.is(CODE_COLON)) {\n                  // 跳过 :\n                  instance.go();\n                  no = instance.scanBinary(index);\n              }\n              if (test && yes && no) {\n                  // 类似 ' a ? 1 : 0 ' 这样的右侧有空格，需要撤回来\n                  instance.skip(-1);\n                  test = createTernary(test, yes, no, instance.pick(index));\n              }\n              else {\n                  instance.fatal(index, \"\\u4E09\\u5143\\u8868\\u8FBE\\u5F0F\\u5199\\u6CD5\\u9519\\u8BEF\");\n              }\n          }\n          // 过掉结束字符\n          if (isDef(endCode)) {\n              instance.skip();\n              if (instance.is(endCode)) {\n                  instance.go();\n              }\n              // 没匹配到结束字符要报错\n              else {\n                  instance.fatal(index, \"\\u7ED3\\u675F\\u5B57\\u7B26\\u5339\\u914D\\u9519\\u8BEF\\uFF0C\\u671F\\u5F85[\" + String.fromCharCode(endCode) + \"]\\uFF0C\\u5374\\u53D1\\u73B0[\" + String.fromCharCode(instance.code) + \"]\");\n              }\n          }\n          return test;\n      };\n      Parser.prototype.fatal = function (start, message) {\n          {\n              fatal(\"Error compiling expression:\\n\" + this.content + \"\\n- \" + message);\n          }\n      };\n      return Parser;\n  }());\n  var cache = {}, CODE_EOF = 0, //\n  CODE_DOT = 46, // .\n  CODE_COMMA = 44, // ,\n  CODE_SLASH = 47, // /\n  CODE_BACKSLASH = 92, // \\\n  CODE_SQUOTE = 39, // '\n  CODE_DQUOTE = 34, // \"\n  CODE_OPAREN = 40, // (\n  CODE_CPAREN = 41, // )\n  CODE_OBRACK = 91, // [\n  CODE_CBRACK = 93, // ]\n  CODE_OBRACE = 123, // {\n  CODE_CBRACE = 125, // }\n  CODE_QUESTION = 63, // ?\n  CODE_COLON = 58, // :\n  CODE_PLUS = 43, // +\n  CODE_MINUS = 45, // -\n  CODE_MULTIPLY = 42, // *\n  CODE_DIVIDE = 47, // /\n  CODE_MODULO = 37, // %\n  CODE_WAVE = 126, // ~\n  CODE_AND = 38, // &\n  CODE_OR = 124, // |\n  CODE_XOR = 94, // ^\n  CODE_NOT = 33, // !\n  CODE_LESS = 60, // <\n  CODE_EQUAL = 61, // =\n  CODE_GREAT = 62, // >\n  /**\n   * 区分关键字和普通变量\n   * 举个例子：a === true\n   * 从解析器的角度来说，a 和 true 是一样的 token\n   */\n  keywordLiterals = {};\n  // object.has 无法判断出 undefined，因此这里改成 ValueHolder 结构\n  keywordLiterals[RAW_TRUE] = { value: TRUE };\n  keywordLiterals[RAW_FALSE] = { value: FALSE };\n  keywordLiterals[RAW_NULL] = { value: NULL };\n  keywordLiterals[RAW_UNDEFINED] = { value: UNDEFINED };\n  /**\n   * 是否是空白符，用下面的代码在浏览器测试一下\n   *\n   * ```\n   * for (var i = 0; i < 200; i++) {\n   *   console.log(i, String.fromCharCode(i))\n   * }\n   * ```\n   *\n   * 从 0 到 32 全是空白符，100 往上分布比较散且较少用，唯一需要注意的是 160\n   *\n   * 160 表示 non-breaking space\n   * http://www.adamkoch.com/2009/07/25/white-space-and-character-160/\n   */\n  function isWhitespace(code) {\n      return (code > 0 && code < 33) || code === 160;\n  }\n  /**\n   * 是否是数字\n   */\n  function isDigit(code) {\n      return code > 47 && code < 58; // 0...9\n  }\n  /**\n   * 是否是数字\n   */\n  function isNumber(code) {\n      return isDigit(code) || code === CODE_DOT;\n  }\n  /**\n   * 变量开始字符必须是 字母、下划线、$\n   */\n  function isIdentifierStart(code) {\n      return code === 36 // $\n          || code === 95 // _\n          || (code > 96 && code < 123) // a...z\n          || (code > 64 && code < 91); // A...Z\n  }\n  /**\n   * 变量剩余的字符必须是 字母、下划线、$、数字\n   */\n  function isIdentifierPart(code) {\n      return isIdentifierStart(code) || isDigit(code);\n  }\n\n  /**\n   * 元素 节点\n   */\n  var ELEMENT = 1;\n  /**\n   * 属性 节点\n   */\n  var ATTRIBUTE = 2;\n  /**\n   * 指令 节点\n   */\n  var DIRECTIVE = 3;\n  /**\n   * 属性 节点\n   */\n  var PROPERTY = 4;\n  /**\n   * 文本 节点\n   */\n  var TEXT = 5;\n  /**\n   * if 节点\n   */\n  var IF = 6;\n  /**\n   * else if 节点\n   */\n  var ELSE_IF = 7;\n  /**\n   * else 节点\n   */\n  var ELSE = 8;\n  /**\n   * each 节点\n   */\n  var EACH = 9;\n  /**\n   * partial 节点\n   */\n  var PARTIAL = 10;\n  /**\n   * import 节点\n   */\n  var IMPORT = 11;\n  /**\n   * 表达式 节点\n   */\n  var EXPRESSION = 12;\n  /**\n   * 延展操作 节点\n   */\n  var SPREAD = 13;\n\n  // 特殊标签\n  var specialTags = {};\n  // 特殊属性\n  var specialAttrs = {};\n  // 名称 -> 类型的映射\n  var name2Type = {};\n  specialTags[RAW_SLOT] =\n      specialTags[RAW_TEMPLATE] =\n          specialAttrs[RAW_KEY] =\n              specialAttrs[RAW_REF] =\n                  specialAttrs[RAW_SLOT] = TRUE;\n  name2Type['if'] = IF;\n  name2Type['each'] = EACH;\n  name2Type['partial'] = PARTIAL;\n\n  var helper = /*#__PURE__*/Object.freeze({\n    specialTags: specialTags,\n    specialAttrs: specialAttrs,\n    name2Type: name2Type\n  });\n\n  function createAttribute(name) {\n      return {\n          type: ATTRIBUTE,\n          isStatic: TRUE,\n          name: name\n      };\n  }\n  function createDirective(ns, name, value, expr, children) {\n      return {\n          type: DIRECTIVE,\n          ns: ns,\n          name: name,\n          key: join$1(ns, name),\n          value: value,\n          expr: expr,\n          children: children\n      };\n  }\n  function createProperty(name, hint, value, expr, children) {\n      return {\n          type: PROPERTY,\n          isStatic: TRUE,\n          name: name,\n          hint: hint,\n          value: value,\n          expr: expr,\n          children: children\n      };\n  }\n  function createEach(expr, index) {\n      return {\n          type: EACH,\n          expr: expr,\n          index: index,\n          isComplex: TRUE\n      };\n  }\n  function createElement(tag, isSvg, isComponent) {\n      // 是 svg 就不可能是组件\n      // 加这个判断的原因是，svg 某些标签含有 连字符 和 大写字母，比较蛋疼\n      if (isSvg) {\n          isComponent = FALSE;\n      }\n      return {\n          type: ELEMENT,\n          tag: tag,\n          isSvg: isSvg,\n          isStyle: tag === 'style',\n          isComponent: isComponent,\n          isStatic: !isComponent && tag !== RAW_SLOT\n      };\n  }\n  function createElse() {\n      return {\n          type: ELSE\n      };\n  }\n  function createElseIf(expr) {\n      return {\n          type: ELSE_IF,\n          expr: expr\n      };\n  }\n  function createExpression(expr, safe) {\n      return {\n          type: EXPRESSION,\n          expr: expr,\n          safe: safe,\n          isLeaf: TRUE\n      };\n  }\n  function createIf(expr) {\n      return {\n          type: IF,\n          expr: expr\n      };\n  }\n  function createImport(name) {\n      return {\n          type: IMPORT,\n          name: name,\n          isComplex: TRUE,\n          isLeaf: TRUE\n      };\n  }\n  function createPartial(name) {\n      return {\n          type: PARTIAL,\n          name: name,\n          isComplex: TRUE\n      };\n  }\n  function createSpread(expr, binding) {\n      return {\n          type: SPREAD,\n          expr: expr,\n          binding: binding,\n          isLeaf: TRUE\n      };\n  }\n  function createText(text) {\n      return {\n          type: TEXT,\n          text: text,\n          isStatic: TRUE,\n          isLeaf: TRUE\n      };\n  }\n\n  // 当前不位于 block 之间\n  var BLOCK_MODE_NONE = 1, \n  // {{ x }}\n  BLOCK_MODE_SAFE = 2, \n  // {{{ x }}}\n  BLOCK_MODE_UNSAFE = 3, \n  // 表达式的静态 keypath\n  STATIC_KEYPATH = 'sk', \n  // 缓存编译模板\n  compileCache = {}, \n  // 缓存编译正则\n  patternCache$1 = {}, \n  // 指令分隔符，如 on-click 和 lazy-click\n  directiveSeparator = '-', \n  // 没有命名空间的事件\n  eventPattern = /^[_$a-z]([\\w]+)?$/i, \n  // 有命名空间的事件\n  eventNamespacePattern = /^[_$a-z]([\\w]+)?\\.[_$a-z]([\\w]+)?$/i, \n  // 标签\n  tagPattern = /<(\\/)?([$a-z][-a-z0-9]*)/i, \n  // 注释\n  commentPattern = /<!--[\\s\\S]*?-->/g, \n  // 属性的 name\n  // 支持 on-click.namespace=\"\" 或 on-get-out=\"\" 或 xml:xx=\"\"\n  attributePattern = /^\\s*([-.:\\w]+)(['\"])?(?:=(['\"]))?/, \n  // 首字母大写，或中间包含 -\n  componentNamePattern = /^[$A-Z]|-/, \n  // 自闭合标签\n  selfClosingTagPattern = /^\\s*(\\/)?>/, \n  // 常见的自闭合标签\n  selfClosingTagNames = 'area,base,embed,track,source,param,input,col,img,br,hr'.split(','), \n  // 常见的 svg 标签\n  svgTagNames = 'svg,g,defs,desc,metadata,symbol,use,image,path,rect,circle,line,ellipse,polyline,polygon,text,tspan,tref,textpath,marker,pattern,clippath,mask,filter,cursor,view,animate,font,font-face,glyph,missing-glyph,foreignObject'.split(','), \n  // 常见的字符串类型的属性\n  // 注意：autocomplete,autocapitalize 不是布尔类型\n  stringProperyNames = 'id,class,name,value,for,accesskey,title,style,src,type,href,target,alt,placeholder,preload,poster,wrap,accept,pattern,dir,autocomplete,autocapitalize'.split(','), \n  // 常见的数字类型的属性\n  numberProperyNames = 'min,minlength,max,maxlength,step,width,height,size,rows,cols,tabindex'.split(','), \n  // 常见的布尔类型的属性\n  booleanProperyNames = 'disabled,checked,required,multiple,readonly,autofocus,autoplay,controls,loop,muted,novalidate,draggable,hidden,spellcheck'.split(','), \n  // 某些属性 attribute name 和 property name 不同\n  attr2Prop = {};\n  // 列举几个常见的\n  attr2Prop['for'] = 'htmlFor';\n  attr2Prop['class'] = 'className';\n  attr2Prop['accesskey'] = 'accessKey';\n  attr2Prop['style'] = 'style.cssText';\n  attr2Prop['novalidate'] = 'noValidate';\n  attr2Prop['readonly'] = 'readOnly';\n  attr2Prop['tabindex'] = 'tabIndex';\n  attr2Prop['minlength'] = 'minLength';\n  attr2Prop['maxlength'] = 'maxLength';\n  /**\n   * 截取前缀之后的字符串\n   */\n  function slicePrefix(str, prefix) {\n      return trim(slice(str, prefix.length));\n  }\n  /**\n   * trim 文本开始和结束位置的换行符\n   *\n   * 换行符比较神奇，有时候你明明看不到换行符，却真的存在一个，那就是 \\r\n   *\n   */\n  function trimBreakline(content) {\n      return content.replace(/^\\s*[\\n\\r]\\s*|\\s*[\\n\\r]\\s*$/g, EMPTY_STRING);\n  }\n  function compile$1(content) {\n      var nodeList = compileCache[content];\n      if (nodeList) {\n          return nodeList;\n      }\n      nodeList = [];\n      var nodeStack = [], \n      // 持有 if/elseif/else 节点\n      ifStack = [], currentElement, currentAttribute, length = content.length, \n      // 当前处理的位置\n      index = 0, \n      // 下一段开始的位置\n      nextIndex = 0, \n      // 开始定界符的位置，表示的是 {{ 的右侧位置\n      openBlockIndex = 0, \n      // 结束定界符的位置，表示的是 }} 的左侧位置\n      closeBlockIndex = 0, \n      // 当前正在处理或即将处理的 block 类型\n      blockMode = BLOCK_MODE_NONE, code, startQuote, fatal$1 = function (msg) {\n          {\n              fatal(\"Error compiling \" + RAW_TEMPLATE + \":\\n\" + content + \"\\n- \" + msg);\n          }\n      }, \n      /**\n       * 常见的两种情况：\n       *\n       * <div>\n       *    <input>1\n       * </div>\n       *\n       * <div>\n       *    <input>\n       * </div>\n       */\n      popSelfClosingElementIfNeeded = function (popingTagName) {\n          var lastNode = last(nodeStack);\n          if (lastNode && lastNode.type === ELEMENT) {\n              var element = lastNode;\n              if (element.tag !== popingTagName\n                  && has(selfClosingTagNames, element.tag)) {\n                  popStack(element.type, element.tag);\n              }\n          }\n      }, popStack = function (type, tagName) {\n          var node = pop(nodeStack);\n          if (node && node.type === type) {\n              var children = node.children, \n              // 优化单个子节点\n              child = children && children.length === 1 && children[0], isElement = type === ELEMENT, isAttribute = type === ATTRIBUTE, isProperty = type === PROPERTY, isDirective = type === DIRECTIVE;\n              var currentBranch = last(nodeStack);\n              if (currentBranch) {\n                  if (currentBranch.isStatic && !node.isStatic) {\n                      currentBranch.isStatic = FALSE;\n                  }\n                  if (!currentBranch.isComplex) {\n                      if (node.isComplex || isElement) {\n                          currentBranch.isComplex = TRUE;\n                      }\n                      // <div {{#if xx}} xx{{/if}}>\n                      else if (currentElement\n                          && currentElement !== currentBranch\n                          && (isAttribute || isProperty || isDirective)) {\n                          currentBranch.isComplex = TRUE;\n                      }\n                  }\n              }\n              {\n                  if (isElement) {\n                      var element = node;\n                      if (tagName && element.tag !== tagName) {\n                          fatal$1(\"\\u7ED3\\u675F\\u6807\\u7B7E\\u662F\" + tagName + \"\\uFF0C\\u5F00\\u59CB\\u6807\\u7B7E\\u5374\\u662F\" + element.tag);\n                      }\n                  }\n              }\n              // 除了 helper.specialAttrs 里指定的特殊属性，attrs 里的任何节点都不能单独拎出来赋给 element\n              // 因为 attrs 可能存在 if，所以每个 attr 最终都不一定会存在\n              if (child) {\n                  switch (child.type) {\n                      case TEXT:\n                          // 属性的值如果是纯文本，直接获取文本值\n                          // 减少渲染时的遍历\n                          if (isElement) ;\n                          else if (isAttribute) {\n                              processAttributeSingleText(node, child);\n                          }\n                          else if (isProperty) {\n                              processPropertySingleText(node, child);\n                          }\n                          else if (isDirective) {\n                              processDirectiveSingleText(node, child);\n                          }\n                          break;\n                      case EXPRESSION:\n                          if (isElement) {\n                              processElementSingleExpression(node, child);\n                          }\n                          else if (isAttribute) {\n                              processAttributeSingleExpression(node, child);\n                          }\n                          else if (isProperty) {\n                              processPropertySingleExpression(node, child);\n                          }\n                          else if (isDirective) {\n                              processDirectiveSingleExpression(node, child);\n                          }\n                          break;\n                  }\n              }\n              // 大于 1 个子节点，即有插值或 if 写法\n              else if (children) {\n                  // 不支持 on-click=\"1{{xx}}2\" 或是 on-click=\"1{{#if x}}x{{else}}y{{/if}}2\"\n                  // 1. 很难做性能优化\n                  // 2. 全局搜索不到事件名，不利于代码维护\n                  // 3. 不利于编译成静态函数\n                  {\n                      if (isDirective) {\n                          fatal$1(\"\\u6307\\u4EE4\\u7684\\u503C\\u4E0D\\u80FD\\u7528\\u63D2\\u503C\\u6216 if \\u8BED\\u6CD5\");\n                      }\n                  }\n              }\n              // 0 个子节点\n              else if (currentElement) {\n                  if (isAttribute) {\n                      processAttributeEmptyChildren(currentElement, node);\n                  }\n                  else if (isProperty) {\n                      processPropertyEmptyChildren(currentElement, node);\n                  }\n                  else if (isDirective) {\n                      processDirectiveEmptyChildren(currentElement, node);\n                  }\n              }\n              if (type === EACH) {\n                  checkEach(node);\n              }\n              else if (type === PARTIAL) {\n                  checkPartial(node);\n              }\n              else if (isElement) {\n                  checkElement(node);\n              }\n              else if (currentElement && isAttribute && isSpecialAttr(currentElement, node)) {\n                  bindSpecialAttr(currentElement, node);\n              }\n              return node;\n          }\n          {\n              fatal$1(\"\\u51FA\\u6808\\u8282\\u70B9\\u7C7B\\u578B\\u4E0D\\u5339\\u914D\");\n          }\n      }, processElementSingleExpression = function (element, child) {\n          if (!element.isComponent && !element.slot && !child.safe) {\n              element.html = child.expr;\n              element.children = UNDEFINED;\n          }\n      }, processPropertyEmptyChildren = function (element, prop) {\n          if (prop.hint === HINT_BOOLEAN) {\n              prop.value = TRUE;\n          }\n          else {\n              // string 或 number 类型的属性，如果不写值，直接忽略\n              replaceChild(prop);\n          }\n      }, processPropertySingleText = function (prop, child) {\n          var text = child.text;\n          if (prop.hint === HINT_NUMBER) {\n              prop.value = toNumber(text);\n          }\n          else if (prop.hint === HINT_BOOLEAN) {\n              prop.value = text === RAW_TRUE || text === prop.name;\n          }\n          else {\n              prop.value = text;\n          }\n          prop.children = UNDEFINED;\n      }, processPropertySingleExpression = function (prop, child) {\n          var expr = child.expr;\n          prop.expr = expr;\n          prop.children = UNDEFINED;\n          // 对于有静态路径的表达式，可转为单向绑定指令，可实现精确更新视图，如下\n          // <div class=\"{{className}}\">\n          if (expr[STATIC_KEYPATH]) {\n              prop.binding = TRUE;\n          }\n      }, processAttributeEmptyChildren = function (element, attr) {\n          var name = attr.name;\n          if (isSpecialAttr(element, attr)) {\n              {\n                  fatal$1(name + \" \\u5FD8\\u4E86\\u5199\\u503C\\u5427\\uFF1F\");\n              }\n          }\n          // 比如 <Dog isLive>\n          else if (element.isComponent) {\n              attr.value = TRUE;\n          }\n          // <div data-name checked>\n          else {\n              attr.value = startsWith(name, 'data-')\n                  ? EMPTY_STRING\n                  : name;\n          }\n      }, processAttributeSingleText = function (attr, child) {\n          attr.value = child.text;\n          attr.children = UNDEFINED;\n      }, processAttributeSingleExpression = function (attr, child) {\n          var expr = child.expr;\n          attr.expr = expr;\n          attr.children = UNDEFINED;\n          // 对于有静态路径的表达式，可转为单向绑定指令，可实现精确更新视图，如下\n          // <div class=\"{{className}}\">\n          if (expr[STATIC_KEYPATH]) {\n              attr.binding = TRUE;\n          }\n      }, processDirectiveEmptyChildren = function (element, directive) {\n          directive.value = TRUE;\n      }, processDirectiveSingleText = function (directive, child) {\n          var text = child.text, \n          // model=\"xx\" model=\"this.x\" 值只能是标识符或 Member\n          isModel = directive.ns === DIRECTIVE_MODEL, \n          // lazy 的值必须是大于 0 的数字\n          isLazy = directive.ns === DIRECTIVE_LAZY, \n          // 校验事件名称\n          isEvent = directive.ns === DIRECTIVE_EVENT, \n          // 自定义指令运行不合法的表达式\n          isCustom = directive.ns === DIRECTIVE_CUSTOM;\n          // 指令的值是纯文本，可以预编译表达式，提升性能\n          var expr;\n          try {\n              expr = compile(text);\n          }\n          catch (_a) { }\n          if (expr) {\n              {\n                  var raw = expr.raw;\n                  if (isLazy) {\n                      if (expr.type !== LITERAL\n                          || !number(expr.value)\n                          || expr.value <= 0) {\n                          fatal$1(\"lazy \\u6307\\u4EE4\\u7684\\u503C [\" + raw + \"] \\u5FC5\\u987B\\u662F\\u5927\\u4E8E 0 \\u7684\\u6570\\u5B57\");\n                      }\n                  }\n                  // 如果指令表达式是函数调用，则只能调用方法（难道还有别的可以调用的吗？）\n                  else if (expr.type === CALL) {\n                      if (expr.name.type !== IDENTIFIER) {\n                          fatal$1('指令表达式的类型如果是函数调用，则只能调用方法');\n                      }\n                  }\n                  // 上面检测过方法调用，接下来事件指令只需要判断是否以下两种格式：\n                  // on-click=\"name\" 或 on-click=\"name.namespace\"\n                  else if (isEvent) {\n                      if (!eventPattern.test(raw) && !eventNamespacePattern.test(raw)) {\n                          fatal$1('事件转换名称只能是 [name] 或 [name.namespace] 格式');\n                      }\n                      else if (currentElement\n                          && currentElement.isComponent\n                          && directive.name === raw) {\n                          fatal$1('转换组件事件的名称不能相同');\n                      }\n                  }\n                  if (isModel && !expr[STATIC_KEYPATH]) {\n                      fatal$1(directive.ns + \" \\u6307\\u4EE4\\u7684\\u503C\\u683C\\u5F0F\\u9519\\u8BEF: [\" + raw + \"]\");\n                  }\n              }\n              directive.expr = expr;\n              directive.value = expr.type === LITERAL\n                  ? expr.value\n                  : text;\n          }\n          else {\n              {\n                  if (!isCustom) {\n                      fatal$1(directive.ns + \" \\u6307\\u4EE4\\u7684\\u8868\\u8FBE\\u5F0F\\u9519\\u8BEF: [\" + text + \"]\");\n                  }\n              }\n              directive.value = text;\n          }\n          directive.children = UNDEFINED;\n      }, processDirectiveSingleExpression = function (directive, child) {\n          {\n              fatal$1(\"\\u6307\\u4EE4\\u7684\\u8868\\u8FBE\\u5F0F\\u4E0D\\u80FD\\u7528\\u63D2\\u503C\\u8BED\\u6CD5\");\n          }\n      }, checkCondition = function (condition) {\n          var currentNode = condition, prevNode, hasChildren, hasNext;\n          // 变成一维数组，方便遍历\n          while (TRUE) {\n              if (currentNode.children) {\n                  if (!hasNext) {\n                      if (currentNode.next) {\n                          delete currentNode.next;\n                      }\n                  }\n                  hasChildren = hasNext = TRUE;\n              }\n              prevNode = currentNode.prev;\n              if (prevNode) {\n                  // prev 仅仅用在 checkCondition 函数中\n                  // 用完就可以删掉了\n                  delete currentNode.prev;\n                  currentNode = prevNode;\n              }\n              else {\n                  break;\n              }\n          }\n          // 每个条件都是空内容，则删掉整个 if\n          if (!hasChildren) {\n              replaceChild(currentNode);\n          }\n      }, checkEach = function (each) {\n          // 没内容就干掉\n          if (!each.children) {\n              replaceChild(each);\n          }\n      }, checkPartial = function (partial) {\n          // 没内容就干掉\n          if (!partial.children) {\n              replaceChild(partial);\n          }\n      }, checkElement = function (element) {\n          {\n              if (element.tag === RAW_TEMPLATE) {\n                  if (element.key) {\n                      fatal$1(\"<template> \\u4E0D\\u652F\\u6301 key\");\n                  }\n                  else if (element.ref) {\n                      fatal$1(\"<template> \\u4E0D\\u652F\\u6301 ref\");\n                  }\n                  else if (element.attrs) {\n                      fatal$1(\"<template> \\u4E0D\\u652F\\u6301\\u5C5E\\u6027\\u6216\\u6307\\u4EE4\");\n                  }\n                  else if (!element.slot) {\n                      fatal$1(\"<template> \\u4E0D\\u5199 slot \\u5C5E\\u6027\\u662F\\u51E0\\u4E2A\\u610F\\u601D\\uFF1F\");\n                  }\n              }\n              else if (element.tag === RAW_SLOT && !element.name) {\n                  fatal$1(\"<slot> \\u4E0D\\u5199 name \\u5C5E\\u6027\\u662F\\u51E0\\u4E2A\\u610F\\u601D\\uFF1F\");\n              }\n          }\n          // style 如果啥都没写，就默认加一个 type=\"text/css\"\n          // 因为低版本 IE 没这个属性，没法正常渲染样式\n          // 如果 style 写了 attribute 那就自己保证吧\n          // 因为 attrs 具有动态性，compiler 无法保证最终一定会输出 type 属性\n          if (element.isStyle && falsy(element.attrs)) {\n              element.attrs = [\n                  createProperty('type', HINT_STRING, 'text/css')\n              ];\n          }\n      }, bindSpecialAttr = function (element, attr) {\n          var name = attr.name, value = attr.value, \n          // 这三个属性值要求是字符串\n          isStringValueRequired = name === RAW_NAME || name === RAW_SLOT;\n          {\n              // 因为要拎出来给 element，所以不能用 if\n              if (last(nodeStack) !== element) {\n                  fatal$1(name + \" \\u4E0D\\u80FD\\u5199\\u5728 if \\u5185\");\n              }\n              // 对于所有特殊属性来说，空字符串是肯定不行的，没有任何意义\n              if (value === EMPTY_STRING) {\n                  fatal$1(name + \" \\u7684\\u503C\\u4E0D\\u80FD\\u662F\\u7A7A\\u5B57\\u7B26\\u4E32\");\n              }\n              else if (isStringValueRequired && falsy$1(value)) {\n                  fatal$1(name + \" \\u7684\\u503C\\u53EA\\u80FD\\u662F\\u5B57\\u7B26\\u4E32\\u5B57\\u9762\\u91CF\");\n              }\n          }\n          element[name] = isStringValueRequired ? value : attr;\n          replaceChild(attr);\n      }, isSpecialAttr = function (element, attr) {\n          return specialAttrs[attr.name]\n              || element.tag === RAW_SLOT && attr.name === RAW_NAME;\n      }, replaceChild = function (oldNode, newNode) {\n          var currentBranch = last(nodeStack), isAttr, list, index;\n          if (currentBranch) {\n              isAttr = currentElement && currentElement === currentBranch;\n              list = isAttr\n                  ? currentBranch.attrs\n                  : currentBranch.children;\n          }\n          else {\n              list = nodeList;\n          }\n          if (list) {\n              index = indexOf(list, oldNode);\n              if (index >= 0) {\n                  if (newNode) {\n                      list[index] = newNode;\n                  }\n                  else {\n                      list.splice(index, 1);\n                      if (currentBranch && !list.length) {\n                          if (isAttr) {\n                              delete currentBranch.attrs;\n                          }\n                          else {\n                              currentBranch.children = UNDEFINED;\n                          }\n                      }\n                  }\n              }\n          }\n      }, addChild = function (node) {\n          /**\n           * <div>\n           *    <input>\n           *    <div></div>\n           * </div>\n           *\n           * <div>\n           *    <input>xxx\n           * </div>\n           */\n          if (!currentElement) {\n              popSelfClosingElementIfNeeded();\n          }\n          var type = node.type, currentBranch = last(nodeStack);\n          // else 系列只是 if 的递进节点，不需要加入 nodeList\n          if (type === ELSE || type === ELSE_IF) {\n              var lastNode = pop(ifStack);\n              if (lastNode) {\n                  // 方便 checkCondition 逆向遍历\n                  node.prev = lastNode;\n                  // lastNode 只能是 if 或 else if 节点\n                  if (lastNode.type === ELSE_IF || lastNode.type === IF) {\n                      lastNode.next = node;\n                      popStack(lastNode.type);\n                      push(ifStack, node);\n                  }\n                  else if (type === ELSE_IF) {\n                      {\n                          fatal$1('大哥，else 后面不能跟 else if 啊');\n                      }\n                  }\n                  else {\n                      fatal$1('大哥，只能写一个 else 啊！！');\n                  }\n              }\n              else {\n                  fatal$1('不写 if 是几个意思？？');\n              }\n          }\n          else {\n              if (currentBranch) {\n                  push(\n                  // 这里不能写 currentElement && !currentAttribute，举个例子\n                  //\n                  // <div id=\"x\" {{#if}} name=\"xx\" alt=\"xx\" {{/if}}\n                  //\n                  // 当 name 属性结束后，条件满足，但此时已不是元素属性层级了\n                  currentElement && currentBranch.type === ELEMENT\n                      ? currentElement.attrs || (currentElement.attrs = [])\n                      : currentBranch.children || (currentBranch.children = []), node);\n              }\n              else {\n                  push(nodeList, node);\n              }\n              if (type === IF) {\n                  // 只要是 if 节点，并且和 element 同级，就加上 stub\n                  // 方便 virtual dom 进行对比\n                  // 这个跟 virtual dom 的实现原理密切相关，不加 stub 会有问题\n                  if (!currentElement) {\n                      node.stub = TRUE;\n                  }\n                  push(ifStack, node);\n              }\n          }\n          if (node.isLeaf) {\n              // 当前树枝节点如果是静态的，一旦加入了一个非静态子节点，改变当前树枝节点的 isStatic\n              // 这里不处理树枝节点的进栈，因为当树枝节点出栈时，还有一次处理机会，那时它的 isStatic 已确定下来，不会再变\n              if (currentBranch) {\n                  if (currentBranch.isStatic && !node.isStatic) {\n                      currentBranch.isStatic = FALSE;\n                  }\n                  // 当前树枝节点是简单节点，一旦加入了一个复杂子节点，当前树枝节点变为复杂节点\n                  if (!currentBranch.isComplex && node.isComplex) {\n                      currentBranch.isComplex = TRUE;\n                  }\n              }\n          }\n          else {\n              push(nodeStack, node);\n          }\n      }, addTextChild = function (text) {\n          // [注意]\n          // 这里不能随便删掉\n          // 因为收集组件的子节点会受影响，举个例子：\n          // <Component>\n          //\n          // </Component>\n          // 按现在的逻辑，这样的组件是没有子节点的，因为在这里过滤掉了，因此该组件没有 slot\n          // 如果这里放开了，组件就会有一个 slot\n          text = trimBreakline(text);\n          if (text) {\n              addChild(createText(text));\n          }\n      }, htmlParsers = [\n          function (content) {\n              if (!currentElement) {\n                  var match = content.match(tagPattern);\n                  // 必须以 <tag 开头才能继续\n                  // 如果 <tag 前面有别的字符，会走进第四个 parser\n                  if (match && match.index === 0) {\n                      var tag = match[2];\n                      if (match[1] === '/') {\n                          /**\n                           * 处理可能存在的自闭合元素，如下\n                           *\n                           * <div>\n                           *    <input>\n                           * </div>\n                           */\n                          popSelfClosingElementIfNeeded(tag);\n                          popStack(ELEMENT, tag);\n                      }\n                      else {\n                          /**\n                           * template 只能写在组件的第一级，如下：\n                           *\n                           * <Component>\n                           *   <template slot=\"xx\">\n                           *     111\n                           *   </template>\n                           * </Component>\n                           */\n                          {\n                              if (tag === RAW_TEMPLATE) {\n                                  var lastNode = last(nodeStack);\n                                  if (!lastNode || !lastNode.isComponent) {\n                                      fatal$1('<template> 只能写在组件标签内');\n                                  }\n                              }\n                          }\n                          var node = createElement(tag, has(svgTagNames, tag), componentNamePattern.test(tag));\n                          addChild(node);\n                          currentElement = node;\n                      }\n                      return match[0];\n                  }\n              }\n          },\n          // 处理标签的 > 或 />，不论开始还是结束标签\n          function (content) {\n              var match = content.match(selfClosingTagPattern);\n              if (match) {\n                  // 处理开始标签的 > 或 />\n                  if (currentElement && !currentAttribute) {\n                      // 自闭合标签\n                      if (match[1] === '/') {\n                          popStack(currentElement.type, currentElement.tag);\n                      }\n                      currentElement = UNDEFINED;\n                  }\n                  // 处理结束标签的 >\n                  return match[0];\n              }\n          },\n          // 处理 attribute directive 的 name 部分\n          function (content) {\n              // 当前在 element 层级\n              if (currentElement && !currentAttribute) {\n                  var match = content.match(attributePattern);\n                  if (match) {\n                      // <div class=\"11 name=\"xxx\"></div>\n                      // 这里会匹配上 xxx\"，match[2] 就是那个引号\n                      {\n                          if (match[2]) {\n                              fatal$1(\"\\u4E0A\\u4E00\\u4E2A\\u5C5E\\u6027\\u4F3C\\u4E4E\\u6CA1\\u6709\\u6B63\\u5E38\\u7ED3\\u675F\");\n                          }\n                      }\n                      var node = void 0, name = match[1];\n                      if (name === DIRECTIVE_MODEL || name === RAW_TRANSITION) {\n                          node = createDirective(camelize(name), EMPTY_STRING);\n                      }\n                      // 这里要用 on- 判断前缀，否则 on 太容易重名了\n                      else if (startsWith(name, DIRECTIVE_ON + directiveSeparator)) {\n                          var event = slicePrefix(name, DIRECTIVE_ON + directiveSeparator);\n                          {\n                              if (!event) {\n                                  fatal$1('缺少事件名称');\n                              }\n                          }\n                          node = createDirective(DIRECTIVE_EVENT, camelize(event));\n                      }\n                      // 当一个元素绑定了多个事件时，可分别指定每个事件的 lazy\n                      // 当只有一个事件时，可简写成 lazy\n                      // <div on-click=\"xx\" lazy-click\n                      else if (startsWith(name, DIRECTIVE_LAZY)) {\n                          var lazy = slicePrefix(name, DIRECTIVE_LAZY);\n                          if (startsWith(lazy, directiveSeparator)) {\n                              lazy = slicePrefix(lazy, directiveSeparator);\n                          }\n                          node = createDirective(DIRECTIVE_LAZY, lazy ? camelize(lazy) : EMPTY_STRING);\n                      }\n                      // 这里要用 o- 判断前缀，否则 o 太容易重名了\n                      else if (startsWith(name, DIRECTIVE_CUSTOM + directiveSeparator)) {\n                          var custom = slicePrefix(name, DIRECTIVE_CUSTOM + directiveSeparator);\n                          {\n                              if (!custom) {\n                                  fatal$1('缺少自定义指令名称');\n                              }\n                          }\n                          node = createDirective(DIRECTIVE_CUSTOM, camelize(custom));\n                      }\n                      else {\n                          // 组件用驼峰格式\n                          if (currentElement.isComponent) {\n                              node = createAttribute(camelize(name));\n                          }\n                          // 原生 dom 属性\n                          else {\n                              // 把 attr 优化成 prop\n                              var lowerName = lower(name);\n                              // <slot> 、<template> 或 svg 中的属性不用识别为 property\n                              if (specialTags[currentElement.tag] || currentElement.isSvg) {\n                                  node = createAttribute(name);\n                              }\n                              // 尝试识别成 property\n                              else if (has(stringProperyNames, lowerName)) {\n                                  node = createProperty(attr2Prop[lowerName] || lowerName, HINT_STRING);\n                              }\n                              else if (has(numberProperyNames, lowerName)) {\n                                  node = createProperty(attr2Prop[lowerName] || lowerName, HINT_NUMBER);\n                              }\n                              else if (has(booleanProperyNames, lowerName)) {\n                                  node = createProperty(attr2Prop[lowerName] || lowerName, HINT_BOOLEAN);\n                              }\n                              // 没辙，还是个 attribute\n                              else {\n                                  node = createAttribute(name);\n                              }\n                          }\n                      }\n                      addChild(node);\n                      // 这里先记下，下一个 handler 要匹配结束引号\n                      startQuote = match[3];\n                      // 有属性值才需要设置 currentAttribute，便于后续收集属性值\n                      if (startQuote) {\n                          currentAttribute = node;\n                      }\n                      else {\n                          popStack(node.type);\n                      }\n                      return match[0];\n                  }\n              }\n          },\n          function (content) {\n              var text, match;\n              // 处理 attribute directive 的 value 部分\n              if (currentAttribute && startQuote) {\n                  match = content.match(patternCache$1[startQuote] || (patternCache$1[startQuote] = new RegExp(startQuote)));\n                  // 有结束引号\n                  if (match) {\n                      text = slice(content, 0, match.index);\n                      addTextChild(text);\n                      text += startQuote;\n                      // attribute directive 结束了\n                      // 此时如果一个值都没收集到，需设置一个空字符串\n                      // 否则无法区分 <div a b=\"\"> 中的 a 和 b\n                      if (!currentAttribute.children) {\n                          addChild(createText(EMPTY_STRING));\n                      }\n                      popStack(currentAttribute.type);\n                      currentAttribute = UNDEFINED;\n                  }\n                  // 没有结束引号，整段匹配\n                  // 如 id=\"1{{x}}2\" 中的 1\n                  else if (blockMode !== BLOCK_MODE_NONE) {\n                      text = content;\n                      addTextChild(text);\n                  }\n                  else {\n                      fatal$1(currentAttribute.name + \" \\u6CA1\\u6709\\u627E\\u5230\\u7ED3\\u675F\\u5F15\\u53F7\");\n                  }\n              }\n              // 如果不加判断，类似 <div {{...obj}}> 这样写，会把空格当做一个属性\n              // 收集文本只有两处：属性值、元素内容\n              // 属性值通过上面的 if 处理过了，这里只需要处理元素内容\n              else if (!currentElement) {\n                  // 获取 <tag 前面的字符\n                  match = content.match(tagPattern);\n                  // 元素层级的注释都要删掉\n                  if (match) {\n                      text = slice(content, 0, match.index);\n                      if (text) {\n                          addTextChild(text.replace(commentPattern, EMPTY_STRING));\n                      }\n                  }\n                  else {\n                      text = content;\n                      addTextChild(text.replace(commentPattern, EMPTY_STRING));\n                  }\n              }\n              else {\n                  {\n                      if (trim(content)) {\n                          fatal$1(\"<\" + currentElement.tag + \"> \\u5C5E\\u6027\\u91CC\\u4E0D\\u8981\\u5199\\u4E71\\u4E03\\u516B\\u7CDF\\u7684\\u5B57\\u7B26\");\n                      }\n                  }\n                  text = content;\n              }\n              return text;\n          } ], blockParsers = [\n          // {{#each xx:index}}\n          function (source) {\n              if (startsWith(source, SYNTAX_EACH)) {\n                  source = slicePrefix(source, SYNTAX_EACH);\n                  var terms = source.replace(/\\s+/g, EMPTY_STRING).split(':');\n                  if (terms[0]) {\n                      var expr = compile(trim(terms[0]));\n                      if (expr) {\n                          if (!currentElement) {\n                              return createEach(expr, trim(terms[1]));\n                          }\n                          else {\n                              fatal$1(currentAttribute\n                                  ? \"each \\u4E0D\\u80FD\\u5199\\u5728\\u5C5E\\u6027\\u7684\\u503C\\u91CC\"\n                                  : \"each \\u4E0D\\u80FD\\u5199\\u5728\\u5C5E\\u6027\\u5C42\\u7EA7\");\n                          }\n                      }\n                  }\n                  {\n                      fatal$1(\"\\u65E0\\u6548\\u7684 each\");\n                  }\n              }\n          },\n          // {{#import name}}\n          function (source) {\n              if (startsWith(source, SYNTAX_IMPORT)) {\n                  source = slicePrefix(source, SYNTAX_IMPORT);\n                  if (source) {\n                      if (!currentElement) {\n                          return createImport(source);\n                      }\n                      else {\n                          fatal$1(currentAttribute\n                              ? \"import \\u4E0D\\u80FD\\u5199\\u5728\\u5C5E\\u6027\\u7684\\u503C\\u91CC\"\n                              : \"import \\u4E0D\\u80FD\\u5199\\u5728\\u5C5E\\u6027\\u5C42\\u7EA7\");\n                      }\n                  }\n                  {\n                      fatal$1(\"\\u65E0\\u6548\\u7684 import\");\n                  }\n              }\n          },\n          // {{#partial name}}\n          function (source) {\n              if (startsWith(source, SYNTAX_PARTIAL)) {\n                  source = slicePrefix(source, SYNTAX_PARTIAL);\n                  if (source) {\n                      if (!currentElement) {\n                          return createPartial(source);\n                      }\n                      else {\n                          fatal$1(currentAttribute\n                              ? \"partial \\u4E0D\\u80FD\\u5199\\u5728\\u5C5E\\u6027\\u7684\\u503C\\u91CC\"\n                              : \"partial \\u4E0D\\u80FD\\u5199\\u5728\\u5C5E\\u6027\\u5C42\\u7EA7\");\n                      }\n                  }\n                  {\n                      fatal$1(\"\\u65E0\\u6548\\u7684 partial\");\n                  }\n              }\n          },\n          // {{#if expr}}\n          function (source) {\n              if (startsWith(source, SYNTAX_IF)) {\n                  source = slicePrefix(source, SYNTAX_IF);\n                  var expr = compile(source);\n                  if (expr) {\n                      return createIf(expr);\n                  }\n                  {\n                      fatal$1(\"\\u65E0\\u6548\\u7684 if\");\n                  }\n              }\n          },\n          // {{else if expr}}\n          function (source) {\n              if (startsWith(source, SYNTAX_ELSE_IF)) {\n                  source = slicePrefix(source, SYNTAX_ELSE_IF);\n                  var expr = compile(source);\n                  if (expr) {\n                      return createElseIf(expr);\n                  }\n                  {\n                      fatal$1(\"\\u65E0\\u6548\\u7684 else if\");\n                  }\n              }\n          },\n          // {{else}}\n          function (source) {\n              if (startsWith(source, SYNTAX_ELSE)) {\n                  source = slicePrefix(source, SYNTAX_ELSE);\n                  if (!trim(source)) {\n                      return createElse();\n                  }\n                  {\n                      fatal$1(\"else \\u540E\\u9762\\u4E0D\\u8981\\u5199\\u4E71\\u4E03\\u516B\\u7CDF\\u7684\\u4E1C\\u897F\");\n                  }\n              }\n          },\n          // {{...obj}}\n          function (source) {\n              if (startsWith(source, SYNTAX_SPREAD)) {\n                  source = slicePrefix(source, SYNTAX_SPREAD);\n                  var expr = compile(source);\n                  if (expr) {\n                      if (currentElement && currentElement.isComponent) {\n                          return createSpread(expr, string(expr[STATIC_KEYPATH])\n                              ? TRUE\n                              : FALSE);\n                      }\n                      else {\n                          fatal$1(\"\\u5EF6\\u5C55\\u5C5E\\u6027\\u53EA\\u80FD\\u7528\\u4E8E\\u7EC4\\u4EF6\\u5C5E\\u6027\");\n                      }\n                  }\n                  {\n                      fatal$1(\"\\u65E0\\u6548\\u7684 spread\");\n                  }\n              }\n          },\n          // {{expr}}\n          function (source) {\n              if (!SYNTAX_COMMENT.test(source)) {\n                  source = trim(source);\n                  var expr = compile(source);\n                  if (expr) {\n                      return createExpression(expr, blockMode === BLOCK_MODE_SAFE);\n                  }\n                  {\n                      fatal$1(\"\\u65E0\\u6548\\u7684 expression\");\n                  }\n              }\n          } ], parseHtml = function (code) {\n          while (code) {\n              each(htmlParsers, function (parse) {\n                  var match = parse(code);\n                  if (match) {\n                      code = slice(code, match.length);\n                      return FALSE;\n                  }\n              });\n          }\n      }, parseBlock = function (code) {\n          if (charAt(code) === '/') {\n              /**\n               * 处理可能存在的自闭合元素，如下\n               *\n               * {{#if xx}}\n               *    <input>\n               * {{/if}}\n               */\n              popSelfClosingElementIfNeeded();\n              var name = slice(code, 1);\n              var type = name2Type[name], isCondition = FALSE;\n              if (type === IF) {\n                  var node_1 = pop(ifStack);\n                  if (node_1) {\n                      type = node_1.type;\n                      isCondition = TRUE;\n                  }\n                  else {\n                      fatal$1(\"if \\u8FD8\\u6CA1\\u5F00\\u59CB\\u5C31\\u7ED3\\u675F\\u4E86\\uFF1F\");\n                  }\n              }\n              var node = popStack(type);\n              if (node && isCondition) {\n                  checkCondition(node);\n              }\n          }\n          else {\n              // 开始下一个 block 或表达式\n              each(blockParsers, function (parse) {\n                  var node = parse(code);\n                  if (node) {\n                      addChild(node);\n                      return FALSE;\n                  }\n              });\n          }\n      };\n      while (TRUE) {\n          openBlockIndex = indexOf$1(content, '{{', nextIndex);\n          if (openBlockIndex >= nextIndex) {\n              blockMode = BLOCK_MODE_SAFE;\n              parseHtml(slice(content, nextIndex, openBlockIndex));\n              // 跳过 {{\n              openBlockIndex += 2;\n              // {{ 后面总得有内容吧\n              if (openBlockIndex < length) {\n                  if (charAt(content, openBlockIndex) === '{') {\n                      blockMode = BLOCK_MODE_UNSAFE;\n                      openBlockIndex++;\n                  }\n                  if (openBlockIndex < length) {\n                      closeBlockIndex = indexOf$1(content, '}}', openBlockIndex);\n                      if (closeBlockIndex >= openBlockIndex) {\n                          // 确定开始和结束定界符能否配对成功，即 {{ 对 }}，{{{ 对 }}}\n                          // 这里不能动 openBlockIndex 和 closeBlockIndex，因为等下要用他俩 slice\n                          index = closeBlockIndex + 2;\n                          // 这里要用 <=，因为很可能到头了\n                          if (index <= length) {\n                              if (index < length && charAt(content, index) === '}') {\n                                  if (blockMode === BLOCK_MODE_UNSAFE) {\n                                      nextIndex = index + 1;\n                                  }\n                                  else {\n                                      fatal$1(\"{{ \\u548C }}} \\u65E0\\u6CD5\\u914D\\u5BF9\");\n                                  }\n                              }\n                              else {\n                                  if (blockMode === BLOCK_MODE_SAFE) {\n                                      nextIndex = index;\n                                  }\n                                  else {\n                                      fatal$1(\"{{{ \\u548C }} \\u65E0\\u6CD5\\u914D\\u5BF9\");\n                                  }\n                              }\n                              code = trim(slice(content, openBlockIndex, closeBlockIndex));\n                              // 不用处理 {{ }} 和 {{{ }}} 这种空 block\n                              if (code) {\n                                  parseBlock(code);\n                              }\n                          }\n                          else {\n                              // 到头了\n                              break;\n                          }\n                      }\n                      else {\n                          fatal$1('找不到结束定界符');\n                      }\n                  }\n                  else {\n                      fatal$1('{{{ 后面没字符串了？');\n                  }\n              }\n              else {\n                  fatal$1('{{ 后面没字符串了？');\n              }\n          }\n          else {\n              blockMode = BLOCK_MODE_NONE;\n              parseHtml(slice(content, nextIndex));\n              break;\n          }\n      }\n      if (nodeStack.length) {\n          /**\n           * 处理可能存在的自闭合元素，如下\n           *\n           * <input>\n           */\n          popSelfClosingElementIfNeeded();\n          {\n              if (nodeStack.length) {\n                  fatal$1('还有节点未出栈');\n              }\n          }\n      }\n      return compileCache[content] = nodeList;\n  }\n\n  function toJSON (target) {\n      return JSON.stringify(target);\n  }\n\n  /**\n   * 这里的难点在于处理 Element 的 children，举个例子：\n   *\n   * ['1', _x(expr), _l(expr, index, generate), _x(expr) ? ['1', _x(expr), _l(expr, index, generate)] : y]\n   *\n   * children 用数组表示，其中表达式求出的值可能是任意类型，比如数组或对象，我们无法控制表达式的值最终会是什么类型\n   *\n   * 像 each 或 import 这样的语法，内部其实会产生一个 vnode 数组，这里就出现了两个难点：\n   *\n   * 1. 如何区分 each 或其他语法产生的数组和表达式求值的数组\n   * 2. 如何避免频繁的创建数组\n   *\n   * 我能想到的解决方案是，根据当前节点类型，如果是元素，则确保 children 的每一项的值序列化后都是函数调用的形式\n   *\n   * 这样能确保是从左到右依次执行，也就便于在内部创建一个公共数组，执行一个函数就收集一个值，而不管那个值到底是什么类型\n   *\n   */\n  // 是否要执行 join 操作\n  var joinStack = [], \n  // 是否正在收集子节点\n  collectStack = [], nodeStringify = {}, RENDER_SLOT = 'a', RENDER_EACH = 'b', RENDER_EXPRESSION = 'c', RENDER_EXPRESSION_ARG = 'd', RENDER_EXPRESSION_VNODE = 'e', RENDER_TEXT_VNODE = 'f', RENDER_ATTRIBUTE_VNODE = 'g', RENDER_PROPERTY_VNODE = 'h', RENDER_LAZY_VNODE = 'i', RENDER_TRANSITION_VNODE = 'j', RENDER_MODEL_VNODE = 'k', RENDER_EVENT_METHOD_VNODE = 'l', RENDER_EVENT_NAME_VNODE = 'm', RENDER_DIRECTIVE_VNODE = 'n', RENDER_SPREAD_VNODE = 'o', RENDER_ELEMENT_VNODE = 'p', RENDER_PARTIAL = 'q', RENDER_IMPORT = 'r', ARG_CONTEXT = 's', SEP_COMMA = ',', SEP_COLON = ':', SEP_PLUS = '+', STRING_TRUE = '!0', STRING_FALSE = '!1', STRING_EMPTY = toJSON(EMPTY_STRING), CODE_RETURN = 'return ', CODE_PREFIX = \"function(\" + join([\n      RENDER_EXPRESSION,\n      RENDER_EXPRESSION_ARG,\n      RENDER_EXPRESSION_VNODE,\n      RENDER_TEXT_VNODE,\n      RENDER_ATTRIBUTE_VNODE,\n      RENDER_PROPERTY_VNODE,\n      RENDER_LAZY_VNODE,\n      RENDER_TRANSITION_VNODE,\n      RENDER_MODEL_VNODE,\n      RENDER_EVENT_METHOD_VNODE,\n      RENDER_EVENT_NAME_VNODE,\n      RENDER_DIRECTIVE_VNODE,\n      RENDER_SPREAD_VNODE,\n      RENDER_ELEMENT_VNODE,\n      RENDER_SLOT,\n      RENDER_PARTIAL,\n      RENDER_IMPORT,\n      RENDER_EACH\n  ], SEP_COMMA) + \"){return \", CODE_SUFFIX = \"}\";\n  // 表达式求值是否要求返回字符串类型\n  var isStringRequired;\n  function stringifyObject(obj) {\n      var fields = [];\n      each$2(obj, function (value, key) {\n          if (isDef(value)) {\n              push(fields, \"\" + toJSON(key) + SEP_COLON + value);\n          }\n      });\n      return \"{\" + join(fields, SEP_COMMA) + \"}\";\n  }\n  function stringifyArray(arr) {\n      return \"[\" + join(arr, SEP_COMMA) + \"]\";\n  }\n  function stringifyCall(name, arg) {\n      return name + \"(\" + arg + \")\";\n  }\n  function stringifyFunction(result, arg) {\n      return \"function(\" + (arg || EMPTY_STRING) + \"){\" + (result || EMPTY_STRING) + \"}\";\n  }\n  function stringifyGroup(code) {\n      return \"(\" + code + \")\";\n  }\n  function stringifyExpression(renderName, expr, extra) {\n      var args = [toJSON(expr)];\n      if (extra) {\n          push(args, extra);\n      }\n      return stringifyCall(renderName, join(args, SEP_COMMA));\n  }\n  function stringifyExpressionArg(expr) {\n      return stringifyExpression(RENDER_EXPRESSION_ARG, expr, [ARG_CONTEXT]);\n  }\n  function stringifyValue(value, expr, children) {\n      if (isDef(value)) {\n          return toJSON(value);\n      }\n      // 只有一个表达式时，保持原始类型\n      if (expr) {\n          return stringifyExpression(RENDER_EXPRESSION, expr);\n      }\n      // 多个值拼接时，要求是字符串\n      if (children) {\n          isStringRequired = children.length > 1;\n          return stringifyChildren(children);\n      }\n  }\n  function stringifyChildren(children, isComplex) {\n      // 如果是复杂节点的 children，则每个 child 的序列化都是函数调用的形式\n      // 因此最后可以拼接为 fn1(), fn2(), fn3() 这样依次调用，而不用再多此一举的使用数组，因为在 renderer 里也用不上这个数组\n      // children 大于一个时，才有 join 的可能，单个值 jion 啥啊...\n      var isJoin = children.length > 1 && !isComplex;\n      push(joinStack, isJoin);\n      var value = join(children.map(function (child) {\n          return nodeStringify[child.type](child);\n      }), isJoin ? SEP_PLUS : SEP_COMMA);\n      pop(joinStack);\n      return value;\n  }\n  function stringifyConditionChildren(children, isComplex) {\n      if (children) {\n          var result = stringifyChildren(children, isComplex);\n          return children.length > 1 && isComplex\n              ? stringifyGroup(result)\n              : result;\n      }\n  }\n  function stringifyIf(node, stub) {\n      var children = node.children, isComplex = node.isComplex, next = node.next, test = stringifyExpression(RENDER_EXPRESSION, node.expr), yes = stringifyConditionChildren(children, isComplex), no, result;\n      if (next) {\n          no = next.type === ELSE\n              ? stringifyConditionChildren(next.children, next.isComplex)\n              : stringifyIf(next, stub);\n      }\n      // 到达最后一个条件，发现第一个 if 语句带有 stub，需创建一个注释标签占位\n      else if (stub) {\n          no = renderElement(stringifyObject({\n              isComment: STRING_TRUE,\n              text: STRING_EMPTY\n          }));\n      }\n      if (isDef(yes) || isDef(no)) {\n          var isJoin = last(joinStack);\n          if (isJoin) {\n              if (!isDef(yes)) {\n                  yes = STRING_EMPTY;\n              }\n              if (!isDef(no)) {\n                  no = STRING_EMPTY;\n              }\n          }\n          if (!isDef(no)) {\n              result = test + \" && \" + yes;\n          }\n          else if (!isDef(yes)) {\n              result = \"!\" + test + \" && \" + no;\n          }\n          else {\n              result = test + \"?\" + yes + \":\" + no;\n          }\n          // 如果是连接操作，因为 ?: 优先级最低，因此要加 ()\n          return isJoin\n              ? stringifyGroup(result)\n              : result;\n      }\n      return STRING_EMPTY;\n  }\n  /**\n   * 目的是 保证调用参数顺序稳定，减少运行时判断\n   */\n  function trimArgs(list) {\n      var args = [], removable = TRUE;\n      each(list, function (arg) {\n          if (isDef(arg)) {\n              removable = FALSE;\n              unshift(args, arg);\n          }\n          else if (!removable) {\n              unshift(args, STRING_FALSE);\n          }\n      }, TRUE);\n      return args;\n  }\n  function renderElement(data, tag, attrs, childs, slots) {\n      return stringifyCall(RENDER_ELEMENT_VNODE, join(trimArgs([data, tag, attrs, childs, slots]), SEP_COMMA));\n  }\n  function getComponentSlots(children) {\n      var result = {}, slots = {}, addSlot = function (name, nodes) {\n          if (!falsy(nodes)) {\n              name = SLOT_DATA_PREFIX + name;\n              push(slots[name] || (slots[name] = []), nodes);\n          }\n      };\n      each(children, function (child) {\n          // 找到具名 slot\n          if (child.type === ELEMENT) {\n              var element = child;\n              if (element.slot) {\n                  addSlot(element.slot, element.tag === RAW_TEMPLATE\n                      ? element.children\n                      : [element]);\n                  return;\n              }\n          }\n          // 匿名 slot，名称统一为 children\n          addSlot(SLOT_NAME_DEFAULT, [child]);\n      });\n      each$2(slots, function (children, name) {\n          // 强制为复杂节点，因为 slot 的子节点不能用字符串拼接的方式来渲染\n          result[name] = stringifyFunction(stringifyChildren(children, TRUE));\n      });\n      if (!falsy$2(result)) {\n          return stringifyObject(result);\n      }\n  }\n  nodeStringify[ELEMENT] = function (node) {\n      var tag = node.tag, isComponent = node.isComponent, isSvg = node.isSvg, isStyle = node.isStyle, isStatic = node.isStatic, isComplex = node.isComplex, name = node.name, ref = node.ref, key = node.key, html = node.html, attrs = node.attrs, children = node.children, data = {}, outputTag, outputAttrs = [], outputChilds, outputSlots, args;\n      if (tag === RAW_SLOT) {\n          args = [toJSON(SLOT_DATA_PREFIX + name)];\n          if (children) {\n              push(args, stringifyFunction(stringifyChildren(children, TRUE)));\n          }\n          return stringifyCall(RENDER_SLOT, join(args, SEP_COMMA));\n      }\n      push(collectStack, FALSE);\n      if (attrs) {\n          each(attrs, function (attr) {\n              push(outputAttrs, nodeStringify[attr.type](attr));\n          });\n      }\n      // 如果以 $ 开头，表示动态组件\n      if (codeAt(tag) === 36) {\n          outputTag = toJSON(slice(tag, 1));\n      }\n      else {\n          data.tag = toJSON(tag);\n      }\n      if (isSvg) {\n          data.isSvg = STRING_TRUE;\n      }\n      if (isStyle) {\n          data.isStyle = STRING_TRUE;\n      }\n      if (isStatic) {\n          data.isStatic = STRING_TRUE;\n      }\n      if (ref) {\n          data.ref = stringifyValue(ref.value, ref.expr, ref.children);\n      }\n      if (key) {\n          data.key = stringifyValue(key.value, key.expr, key.children);\n      }\n      if (html) {\n          data.html = stringifyExpression(RENDER_EXPRESSION, html, [STRING_TRUE]);\n      }\n      if (isComponent) {\n          data.isComponent = STRING_TRUE;\n          if (children) {\n              collectStack[collectStack.length - 1] = TRUE;\n              outputSlots = getComponentSlots(children);\n          }\n      }\n      else if (children) {\n          isStringRequired = TRUE;\n          collectStack[collectStack.length - 1] = isComplex;\n          outputChilds = stringifyChildren(children, isComplex);\n          if (isComplex) {\n              outputChilds = stringifyFunction(outputChilds);\n          }\n          else {\n              data.text = outputChilds;\n              outputChilds = UNDEFINED;\n          }\n      }\n      pop(collectStack);\n      return renderElement(stringifyObject(data), outputTag, falsy(outputAttrs)\n          ? UNDEFINED\n          : stringifyFunction(join(outputAttrs, SEP_COMMA)), outputChilds, outputSlots);\n  };\n  nodeStringify[ATTRIBUTE] = function (node) {\n      var binding = node.binding;\n      return stringifyCall(RENDER_ATTRIBUTE_VNODE, join(trimArgs([\n          toJSON(node.name),\n          binding ? STRING_TRUE : UNDEFINED,\n          binding ? toJSON(node.expr) : UNDEFINED,\n          binding ? UNDEFINED : stringifyValue(node.value, node.expr, node.children)\n      ]), SEP_COMMA));\n  };\n  nodeStringify[PROPERTY] = function (node) {\n      var binding = node.binding;\n      return stringifyCall(RENDER_PROPERTY_VNODE, join(trimArgs([\n          toJSON(node.name),\n          toJSON(node.hint),\n          binding ? STRING_TRUE : UNDEFINED,\n          binding ? toJSON(node.expr) : UNDEFINED,\n          binding ? UNDEFINED : stringifyValue(node.value, node.expr, node.children)\n      ]), SEP_COMMA));\n  };\n  nodeStringify[DIRECTIVE] = function (node) {\n      var ns = node.ns, name = node.name, key = node.key, value = node.value, expr = node.expr;\n      if (ns === DIRECTIVE_LAZY) {\n          return stringifyCall(RENDER_LAZY_VNODE, join([toJSON(name), toJSON(value)], SEP_COMMA));\n      }\n      if (ns === RAW_TRANSITION) {\n          return stringifyCall(RENDER_TRANSITION_VNODE, toJSON(value));\n      }\n      // <input model=\"id\">\n      if (ns === DIRECTIVE_MODEL) {\n          return stringifyCall(RENDER_MODEL_VNODE, toJSON(expr));\n      }\n      var renderName = RENDER_DIRECTIVE_VNODE, args = [\n          toJSON(name),\n          toJSON(key),\n          toJSON(value) ];\n      // 尽可能把表达式编译成函数，这样对外界最友好\n      //\n      // 众所周知，事件指令会编译成函数，对于自定义指令来说，也要尽可能编译成函数\n      //\n      // 比如 o-tap=\"method()\" 或 o-log=\"{'id': '11'}\"\n      // 前者会编译成 handler（调用方法），后者会编译成 getter（取值）\n      if (expr) {\n          // 如果表达式明确是在调用方法，则序列化成 method + args 的形式\n          if (expr.type === CALL) {\n              if (ns === DIRECTIVE_EVENT) {\n                  renderName = RENDER_EVENT_METHOD_VNODE;\n              }\n              // compiler 保证了函数调用的 name 是标识符\n              push(args, toJSON(expr.name.name));\n              // 为了实现运行时动态收集参数，这里序列化成函数\n              if (!falsy(expr.args)) {\n                  // args 函数在触发事件时调用，调用时会传入它的作用域，因此这里要加一个参数\n                  push(args, stringifyFunction(CODE_RETURN + stringifyArray(expr.args.map(stringifyExpressionArg)), ARG_CONTEXT));\n              }\n          }\n          // 不是调用方法，就是事件转换\n          else if (ns === DIRECTIVE_EVENT) {\n              renderName = RENDER_EVENT_NAME_VNODE;\n              push(args, toJSON(expr.raw));\n          }\n          else if (ns === DIRECTIVE_CUSTOM) {\n              // 取值函数\n              // getter 函数在触发事件时调用，调用时会传入它的作用域，因此这里要加一个参数\n              if (expr.type !== LITERAL) {\n                  push(args, UNDEFINED); // method\n                  push(args, UNDEFINED); // args\n                  push(args, stringifyFunction(CODE_RETURN + stringifyExpressionArg(expr), ARG_CONTEXT));\n              }\n          }\n      }\n      return stringifyCall(renderName, join(trimArgs(args), SEP_COMMA));\n  };\n  nodeStringify[SPREAD] = function (node) {\n      return stringifyCall(RENDER_SPREAD_VNODE, join(trimArgs([toJSON(node.expr), node.binding ? STRING_TRUE : UNDEFINED]), SEP_COMMA));\n  };\n  nodeStringify[TEXT] = function (node) {\n      var result = toJSON(node.text);\n      if (last(collectStack) && !last(joinStack)) {\n          return stringifyCall(RENDER_TEXT_VNODE, result);\n      }\n      return result;\n  };\n  nodeStringify[EXPRESSION] = function (node) {\n      // 强制保留 isStringRequired 参数，减少运行时判断参数是否存在\n      // 因为还有 stack 参数呢，各种判断真的很累\n      var renderName = RENDER_EXPRESSION, args = [isStringRequired ? STRING_TRUE : UNDEFINED];\n      if (last(collectStack) && !last(joinStack)) {\n          renderName = RENDER_EXPRESSION_VNODE;\n      }\n      return stringifyExpression(renderName, node.expr, trimArgs(args));\n  };\n  nodeStringify[IF] = function (node) {\n      return stringifyIf(node, node.stub);\n  };\n  nodeStringify[EACH] = function (node) {\n      // compiler 保证了 children 一定有值\n      var generate = stringifyFunction(stringifyChildren(node.children, node.isComplex));\n      return stringifyCall(RENDER_EACH, join(trimArgs([generate, toJSON(node.expr), node.index ? toJSON(node.index) : UNDEFINED]), SEP_COMMA));\n  };\n  nodeStringify[PARTIAL] = function (node) {\n      var name = toJSON(node.name), \n      // compiler 保证了 children 一定有值\n      children = stringifyFunction(stringifyChildren(node.children, node.isComplex));\n      return stringifyCall(RENDER_PARTIAL, \"\" + name + SEP_COMMA + children);\n  };\n  nodeStringify[IMPORT] = function (node) {\n      var name = toJSON(node.name);\n      return stringifyCall(RENDER_IMPORT, \"\" + name);\n  };\n  function stringify(node) {\n      return CODE_PREFIX + nodeStringify[node.type](node) + CODE_SUFFIX;\n  }\n  function hasStringify(code) {\n      return startsWith(code, CODE_PREFIX);\n  }\n\n  function isUndef (target) {\n      return target === UNDEFINED;\n  }\n\n  var nodeExecutor = {};\n  nodeExecutor[LITERAL] = function (node) {\n      return node.value;\n  };\n  nodeExecutor[IDENTIFIER] = function (node, getter) {\n      return getter(node.name, node);\n  };\n  nodeExecutor[MEMBER] = function (node, getter, context) {\n      /**\n       * 先说第一种奇葩情况：\n       *\n       * 'xx'.length\n       *\n       * 没有变量数据，直接执行字面量，这里用不上 getter\n       *\n       * 第二种：\n       *\n       * a.b.c\n       *\n       * 这是常规操作\n       *\n       * 第三种：\n       *\n       * 'xx'[name]\n       *\n       * 以字面量开头，后面会用到变量\n       *\n       */\n      var staticKeypath = node.sk, props = node.props, first, data;\n      if (isUndef(staticKeypath)) {\n          // props 至少两个，否则无法创建 Member\n          first = props[0];\n          if (first.type === IDENTIFIER) {\n              staticKeypath = first.name;\n          }\n          else {\n              staticKeypath = EMPTY_STRING;\n              data = execute$1(first, getter, context);\n          }\n          for (var i = 1, len = props.length; i < len; i++) {\n              staticKeypath = join$1(staticKeypath, execute$1(props[i], getter, context));\n          }\n      }\n      if (isDef(data)) {\n          data = get(data, staticKeypath);\n          return data ? data.value : UNDEFINED;\n      }\n      if (getter) {\n          return getter(staticKeypath, node);\n      }\n  };\n  nodeExecutor[UNARY] = function (node, getter, context) {\n      return unary[node.op].exec(execute$1(node.a, getter, context));\n  };\n  nodeExecutor[BINARY] = function (node, getter, context) {\n      return binary[node.op].exec(execute$1(node.a, getter, context), execute$1(node.b, getter, context));\n  };\n  nodeExecutor[TERNARY] = function (node, getter, context) {\n      return execute$1(node.test, getter, context)\n          ? execute$1(node.yes, getter, context)\n          : execute$1(node.no, getter, context);\n  };\n  nodeExecutor[ARRAY] = function (node, getter, context) {\n      return node.nodes.map(function (node) {\n          return execute$1(node, getter, context);\n      });\n  };\n  nodeExecutor[OBJECT] = function (node, getter, context) {\n      var result = {};\n      each(node.keys, function (key, index) {\n          result[key] = execute$1(node.values[index], getter, context);\n      });\n      return result;\n  };\n  nodeExecutor[CALL] = function (node, getter, context) {\n      return execute(execute$1(node.name, getter, context), context, node.args.map(function (node) {\n          return execute$1(node, getter, context);\n      }));\n  };\n  function execute$1(node, getter, context) {\n      return nodeExecutor[node.type](node, getter, context);\n  }\n\n  function setPair(target, name, key, value) {\n      var data = target[name] || (target[name] = {});\n      data[key] = value;\n  }\n  function render(context, template, filters, partials, directives, transitions) {\n      var $keypath = EMPTY_STRING, $scope = { $keypath: $keypath }, $stack = [$keypath, $scope], $vnode, vnodeStack = [], localPartials = {}, lookup = function (stack, index, key, node, depIgnore, defaultKeypath) {\n          var keypath = join$1(stack[index], key), scope = stack[index + 1];\n          node.ak = keypath;\n          // 如果最后还是取不到值，用回最初的 keypath\n          if (isUndef(defaultKeypath)) {\n              defaultKeypath = keypath;\n          }\n          // 如果取的是 scope 上直接有的数据，如 $keypath\n          if (isDef(scope[key])) {\n              return scope[key];\n          }\n          // 如果取的是数组项，则要更进一步\n          if (isDef(scope.$item)) {\n              scope = scope.$item;\n              // 到这里 scope 可能为空\n              // 比如 new Array(10) 然后遍历这个数组，每一项肯定是空\n              // 取 this\n              if (key === EMPTY_STRING) {\n                  return scope;\n              }\n              // 取 this.xx\n              if (scope != NULL && isDef(scope[key])) {\n                  return scope[key];\n              }\n          }\n          // 正常取数据\n          var result = context.get(keypath, lookup, depIgnore);\n          if (result === lookup) {\n              // undefined 或 true 都表示需要向上寻找\n              if (node.lookup !== FALSE && index > 1) {\n                  index -= 2;\n                  {\n                      debug(\"Can't find [\" + keypath + \"], start looking up.\");\n                  }\n                  return lookup(stack, index, key, node, depIgnore, defaultKeypath);\n              }\n              var holder = get(filters, key);\n              return holder\n                  ? holder.value\n                  : (node.ak = defaultKeypath, UNDEFINED);\n          }\n          return result;\n      }, getValue = function (expr, depIgnore, stack) {\n          var renderStack = stack || $stack, length = renderStack.length;\n          return execute$1(expr, function (keypath, node) {\n              return lookup(renderStack, length - 2 * ((node.offset || 0) + 1), keypath, node, depIgnore);\n          }, context);\n      }, addBinding = function (vnode, name, expr, hint) {\n          var value = getValue(expr, TRUE), key = join$1(DIRECTIVE_BINDING, name);\n          setPair(vnode, 'directives', key, {\n              ns: DIRECTIVE_BINDING,\n              name: name,\n              key: key,\n              hooks: directives[DIRECTIVE_BINDING],\n              binding: expr.ak,\n              hint: hint\n          });\n          return value;\n      }, createEventListener = function (type) {\n          return function (event, data) {\n              // 事件名称相同的情况，只可能是监听 DOM 事件，比如写一个 Button 组件\n              // <button on-click=\"click\"> 纯粹的封装了一个原生 click 事件\n              if (type !== event.type) {\n                  event = new CustomEvent(type, event);\n              }\n              context.fire(event, data);\n          };\n      }, createMethodListener = function (name, args, stack) {\n          return function (event, data) {\n              var method = context[name];\n              if (event instanceof CustomEvent) {\n                  var result = UNDEFINED;\n                  if (args) {\n                      var scope = last(stack);\n                      if (scope) {\n                          scope.$event = event;\n                          scope.$data = data;\n                          result = execute(method, context, args(stack));\n                          scope.$event =\n                              scope.$data = UNDEFINED;\n                      }\n                  }\n                  else {\n                      result = execute(method, context, data ? [event, data] : event);\n                  }\n                  return result;\n              }\n              else {\n                  execute(method, context, args ? args(stack) : UNDEFINED);\n              }\n          };\n      }, createGetter = function (getter, stack) {\n          return function () {\n              return getter(stack);\n          };\n      }, renderExpression = function (expr, stringRequired) {\n          var value = getValue(expr);\n          return stringRequired\n              ? toString(value)\n              : value;\n      }, renderExpressionArg = function (expr, stack) {\n          return getValue(expr, UNDEFINED, stack);\n      }, renderExpressionVnode = function (expr, stringRequired) {\n          renderTextVnode(renderExpression(expr, stringRequired));\n      }, renderTextVnode = function (text) {\n          var vnodeList = last(vnodeStack);\n          if (vnodeList) {\n              var lastVnode = last(vnodeList);\n              if (lastVnode && lastVnode.isText) {\n                  lastVnode.text += text;\n              }\n              else {\n                  var textVnode = {\n                      isText: TRUE,\n                      text: text,\n                      context: context,\n                      keypath: $keypath\n                  };\n                  push(vnodeList, textVnode);\n              }\n          }\n      }, renderAttributeVnode = function (name, binding, expr, value) {\n          if (binding) {\n              value = addBinding($vnode, name, expr);\n          }\n          if ($vnode.isComponent) {\n              setPair($vnode, 'props', name, value);\n          }\n          else {\n              setPair($vnode, 'nativeAttrs', name, { name: name, value: value });\n          }\n      }, renderPropertyVnode = function (name, hint, binding, expr, value) {\n          if (binding) {\n              value = addBinding($vnode, name, expr, hint);\n          }\n          setPair($vnode, 'nativeProps', name, { name: name, value: value, hint: hint });\n      }, renderLazyVnode = function (name, value) {\n          setPair($vnode, 'lazy', name, value);\n      }, renderTransitionVnode = function (name) {\n          $vnode.transition = transitions[name];\n          {\n              if (!$vnode.transition) {\n                  fatal(\"transition [\" + name + \"] is not found.\");\n              }\n          }\n      }, renderModelVnode = function (expr) {\n          $vnode.model = getValue(expr, TRUE);\n          setPair($vnode, 'directives', DIRECTIVE_MODEL, {\n              ns: DIRECTIVE_MODEL,\n              name: EMPTY_STRING,\n              key: DIRECTIVE_MODEL,\n              binding: expr.ak,\n              hooks: directives[DIRECTIVE_MODEL]\n          });\n      }, renderEventMethodVnode = function (name, key, value, method, args) {\n          setPair($vnode, 'directives', key, {\n              ns: DIRECTIVE_EVENT,\n              name: name,\n              key: key,\n              value: value,\n              hooks: directives[DIRECTIVE_EVENT],\n              handler: createMethodListener(method, args, $stack)\n          });\n      }, renderEventNameVnode = function (name, key, value, event) {\n          setPair($vnode, 'directives', key, {\n              ns: DIRECTIVE_EVENT,\n              name: name,\n              key: key,\n              value: value,\n              hooks: directives[DIRECTIVE_EVENT],\n              handler: createEventListener(event)\n          });\n      }, renderDirectiveVnode = function (name, key, value, method, args, getter) {\n          var hooks = directives[name];\n          {\n              if (!hooks) {\n                  fatal(\"directive [\" + name + \"] is not found.\");\n              }\n          }\n          setPair($vnode, 'directives', key, {\n              ns: DIRECTIVE_CUSTOM,\n              name: name,\n              key: key,\n              value: value,\n              hooks: hooks,\n              getter: getter ? createGetter(getter, $stack) : UNDEFINED,\n              handler: method ? createMethodListener(method, args, $stack) : UNDEFINED\n          });\n      }, renderSpreadVnode = function (expr, binding) {\n          var value = getValue(expr, binding);\n          // 数组也算一种对象，要排除掉\n          if (object(value) && !array(value)) {\n              each$2(value, function (value, key) {\n                  setPair($vnode, 'props', key, value);\n              });\n              var absoluteKeypath = expr['ak'];\n              if (absoluteKeypath) {\n                  var key = join$1(DIRECTIVE_BINDING, absoluteKeypath);\n                  setPair($vnode, 'directives', key, {\n                      ns: DIRECTIVE_BINDING,\n                      name: EMPTY_STRING,\n                      key: key,\n                      hooks: directives[DIRECTIVE_BINDING],\n                      binding: join$1(absoluteKeypath, RAW_WILDCARD)\n                  });\n              }\n          }\n          else {\n              warn(\"[\" + expr.raw + \"] \\u4E0D\\u662F\\u5BF9\\u8C61\\uFF0C\\u5EF6\\u5C55\\u4E2A\\u6BDB\\u554A\");\n          }\n      }, renderElementVnode = function (vnode, tag, attrs, childs, slots) {\n          if (tag) {\n              var componentName = context.get(tag);\n              {\n                  if (!componentName) {\n                      error(\"Dynamic component [\" + tag + \"] is not found.\");\n                  }\n              }\n              vnode.tag = componentName;\n          }\n          if (attrs) {\n              $vnode = vnode;\n              attrs();\n              $vnode = UNDEFINED;\n          }\n          // childs 和 slots 不可能同时存在\n          if (childs) {\n              vnodeStack.push(vnode.children = []);\n              childs();\n              pop(vnodeStack);\n          }\n          else if (slots) {\n              var renderSlots_1 = {};\n              each$2(slots, function (slot, name) {\n                  vnodeStack.push([]);\n                  slot();\n                  renderSlots_1[name] = pop(vnodeStack);\n              });\n              vnode.slots = renderSlots_1;\n          }\n          vnode.context = context;\n          vnode.keypath = $keypath;\n          var vnodeList = last(vnodeStack);\n          if (vnodeList) {\n              push(vnodeList, vnode);\n          }\n          return vnode;\n      }, \n      // <slot name=\"xx\"/>\n      renderSlot = function (name, defaultRender) {\n          var vnodeList = last(vnodeStack), vnodes = context.get(name);\n          if (vnodeList) {\n              if (vnodes) {\n                  each(vnodes, function (vnode) {\n                      push(vnodeList, vnode);\n                      vnode.slot = name;\n                      vnode.parent = context;\n                  });\n              }\n              else if (defaultRender) {\n                  defaultRender();\n              }\n          }\n      }, \n      // {{#partial name}}\n      //   xx\n      // {{/partial}}\n      renderPartial = function (name, render) {\n          localPartials[name] = render;\n      }, \n      // {{> name}}\n      renderImport = function (name) {\n          if (localPartials[name]) {\n              localPartials[name]();\n          }\n          else {\n              var partial = partials[name];\n              if (partial) {\n                  partial(renderExpression, renderExpressionArg, renderExpressionVnode, renderTextVnode, renderAttributeVnode, renderPropertyVnode, renderLazyVnode, renderTransitionVnode, renderModelVnode, renderEventMethodVnode, renderEventNameVnode, renderDirectiveVnode, renderSpreadVnode, renderElementVnode, renderSlot, renderPartial, renderImport, renderEach);\n              }\n              else {\n                  fatal(\"partial [\" + name + \"] is not found.\");\n              }\n          }\n      }, renderEach = function (handler, expr, index) {\n          var value = getValue(expr), exprKeypath = expr['ak'], eachKeypath = exprKeypath || join$1($keypath, expr.raw), callback = function (item, key, length) {\n              var lastKeypath = $keypath, lastScope = $scope, lastKeypathStack = $stack;\n              $keypath = join$1(eachKeypath, toString(key));\n              $scope = {};\n              $stack = copy($stack);\n              push($stack, $keypath);\n              push($stack, $scope);\n              // 从下面这几句赋值可以看出\n              // scope 至少会有 '$keypath' '$length' '$item' index 等几个值\n              $scope.$keypath = $keypath;\n              // 避免模板里频繁读取 list.length\n              $scope.$length = length;\n              // 类似 {{#each 1 -> 10}} 这样的临时循环，需要在 scope 上加上当前项\n              // 因为通过 context.get() 无法获取数据\n              if (!exprKeypath) {\n                  $scope.$item = item;\n              }\n              if (index) {\n                  $scope[index] = key;\n              }\n              handler();\n              $keypath = lastKeypath;\n              $scope = lastScope;\n              $stack = lastKeypathStack;\n          };\n          if (array(value)) {\n              each(value, callback);\n          }\n          else if (object(value)) {\n              each$2(value, callback);\n          }\n          else if (func(value)) {\n              value(callback);\n          }\n      };\n      return template(renderExpression, renderExpressionArg, renderExpressionVnode, renderTextVnode, renderAttributeVnode, renderPropertyVnode, renderLazyVnode, renderTransitionVnode, renderModelVnode, renderEventMethodVnode, renderEventNameVnode, renderDirectiveVnode, renderSpreadVnode, renderElementVnode, renderSlot, renderPartial, renderImport, renderEach);\n  }\n\n  /**\n   * 计算属性\n   *\n   * 可配置 cache、deps、get、set 等\n   */\n  var Computed = /** @class */ (function () {\n      function Computed(keypath, sync, cache, deps, observer, getter, setter) {\n          var instance = this;\n          instance.keypath = keypath;\n          instance.cache = cache;\n          instance.deps = deps;\n          instance.context = observer.context;\n          instance.observer = observer;\n          instance.getter = getter;\n          instance.setter = setter;\n          instance.unique = {};\n          instance.watcher = function ($0, $1, $2) {\n              // 计算属性的依赖变了会走进这里\n              var oldValue = instance.value, newValue = instance.get(TRUE);\n              if (newValue !== oldValue) {\n                  observer.diff(keypath, newValue, oldValue);\n              }\n          };\n          instance.watcherOptions = {\n              sync: sync,\n              watcher: instance.watcher\n          };\n          if (instance.fixed = !falsy(deps)) {\n              each(deps, function (dep) {\n                  observer.watch(dep, instance.watcherOptions);\n              });\n          }\n      }\n      /**\n       * 对外的构造器，把用户配置的计算属性对象转换成内部对象\n       *\n       * @param keypath\n       * @param observer\n       * @param options\n       */\n      Computed.build = function (keypath, observer, options) {\n          var cache = TRUE, sync = TRUE, deps = [], getter, setter;\n          if (func(options)) {\n              getter = options;\n          }\n          else if (object(options)) {\n              if (boolean(options.cache)) {\n                  cache = options.cache;\n              }\n              if (boolean(options.sync)) {\n                  sync = options.sync;\n              }\n              // 因为可能会修改 deps，所以这里创建一个新的 deps，避免影响外部传入的 deps\n              if (array(options.deps)) {\n                  deps = copy(options.deps);\n              }\n              if (func(options.get)) {\n                  getter = options.get;\n              }\n              if (func(options.set)) {\n                  setter = options.set;\n              }\n          }\n          if (getter) {\n              return new Computed(keypath, sync, cache, deps, observer, getter, setter);\n          }\n      };\n      /**\n       * 读取计算属性的值\n       *\n       * @param force 是否强制刷新缓存\n       */\n      Computed.prototype.get = function (force) {\n          var instance = this, getter = instance.getter, context = instance.context;\n          // 禁用缓存\n          if (!instance.cache) {\n              instance.value = execute(getter, context);\n          }\n          // 减少取值频率，尤其是处理复杂的计算规则\n          else if (force || !has$2(instance, RAW_VALUE)) {\n              // 如果写死了依赖，则不需要收集依赖\n              if (instance.fixed) {\n                  instance.value = execute(getter, context);\n              }\n              else {\n                  // 清空上次收集的依赖\n                  instance.unbind();\n                  // 开始收集新的依赖\n                  var lastComputed = Computed.current;\n                  Computed.current = instance;\n                  instance.value = execute(getter, context);\n                  // 绑定新的依赖\n                  instance.bind();\n                  Computed.current = lastComputed;\n              }\n          }\n          return instance.value;\n      };\n      Computed.prototype.set = function (value) {\n          var _a = this, setter = _a.setter, context = _a.context;\n          if (setter) {\n              setter.call(context, value);\n          }\n      };\n      /**\n       * 添加依赖\n       *\n       * 这里只是为了保证依赖唯一，最后由 bind() 实现绑定\n       *\n       * @param dep\n       */\n      Computed.prototype.add = function (dep) {\n          this.unique[dep] = TRUE;\n      };\n      /**\n       * 绑定依赖\n       */\n      Computed.prototype.bind = function () {\n          var _a = this, unique = _a.unique, deps = _a.deps, observer = _a.observer, watcherOptions = _a.watcherOptions;\n          each$2(unique, function (_, dep) {\n              push(deps, dep);\n              observer.watch(dep, watcherOptions);\n          });\n          // 用完重置\n          // 方便下次收集依赖\n          this.unique = {};\n      };\n      /**\n       * 解绑依赖\n       */\n      Computed.prototype.unbind = function () {\n          var _a = this, deps = _a.deps, observer = _a.observer, watcher = _a.watcher;\n          each(deps, function (dep) {\n              observer.unwatch(dep, watcher);\n          }, TRUE);\n          deps.length = 0;\n      };\n      return Computed;\n  }());\n\n  /**\n   * 从 keypath 数组中选择和 keypath 最匹配的那一个\n   *\n   * @param sorted 经过排序的 keypath 数组\n   * @param keypath\n   */\n  function matchBest (sorted, keypath) {\n      var result;\n      each(sorted, function (prefix) {\n          var length = match(keypath, prefix);\n          if (length >= 0) {\n              result = {\n                  name: prefix,\n                  prop: slice(keypath, length)\n              };\n              return FALSE;\n          }\n      });\n      return result;\n  }\n\n  function readValue (source, keypath) {\n      if (source == NULL || keypath === EMPTY_STRING) {\n          return source;\n      }\n      var result = get(source, keypath);\n      if (result) {\n          return result.value;\n      }\n  }\n\n  /**\n   * 对比新旧数组\n   *\n   * @param newValue\n   * @param oldValue\n   * @param callback\n   */\n  function diffString (newValue, oldValue, callback) {\n      var newIsString = string(newValue), oldIsString = string(oldValue);\n      if (newIsString || oldIsString) {\n          callback(RAW_LENGTH, newIsString ? newValue.length : UNDEFINED, oldIsString ? oldValue.length : UNDEFINED);\n          return TRUE;\n      }\n  }\n\n  /**\n   * 对比新旧数组\n   *\n   * @param newValue\n   * @param oldValue\n   * @param callback\n   */\n  function diffArray (newValue, oldValue, callback) {\n      var newIsArray = array(newValue), oldIsArray = array(oldValue);\n      if (newIsArray || oldIsArray) {\n          var newLength = newIsArray ? newValue.length : UNDEFINED, oldLength = oldIsArray ? oldValue.length : UNDEFINED;\n          callback(RAW_LENGTH, newLength, oldLength);\n          for (var i = 0, length = Math.max(newLength || 0, oldLength || 0); i < length; i++) {\n              callback('' + i, newValue ? newValue[i] : UNDEFINED, oldValue ? oldValue[i] : UNDEFINED);\n          }\n          return TRUE;\n      }\n  }\n\n  /**\n   * 对比新旧对象\n   *\n   * @param newValue\n   * @param oldValue\n   * @param callback\n   */\n  function diffObject (newValue, oldValue, callback) {\n      var newIsObject = object(newValue), oldIsObject = object(oldValue);\n      if (newIsObject || oldIsObject) {\n          newValue = newIsObject ? newValue : EMPTY_OBJECT;\n          oldValue = oldIsObject ? oldValue : EMPTY_OBJECT;\n          if (newIsObject) {\n              each$2(newValue, function (value, key) {\n                  if (value !== oldValue[key]) {\n                      callback(key, value, oldValue[key]);\n                  }\n              });\n          }\n          if (oldIsObject) {\n              each$2(oldValue, function (value, key) {\n                  if (value !== newValue[key]) {\n                      callback(key, newValue[key], value);\n                  }\n              });\n          }\n      }\n  }\n\n  function diffRecursion(keypath, newValue, oldValue, watchFuzzyKeypaths, callback) {\n      var diff = function (subKeypath, subNewValue, subOldValue) {\n          if (subNewValue !== subOldValue) {\n              var newKeypath_1 = join$1(keypath, subKeypath);\n              each(watchFuzzyKeypaths, function (fuzzyKeypath) {\n                  if (isDef(matchFuzzy(newKeypath_1, fuzzyKeypath))) {\n                      callback(fuzzyKeypath, newKeypath_1, subNewValue, subOldValue);\n                  }\n              });\n              diffRecursion(newKeypath_1, subNewValue, subOldValue, watchFuzzyKeypaths, callback);\n          }\n      };\n      diffString(newValue, oldValue, diff)\n          || diffArray(newValue, oldValue, diff)\n          || diffObject(newValue, oldValue, diff);\n  }\n\n  function diffWatcher (keypath, newValue, oldValue, watcher, isRecursive, callback) {\n      var fuzzyKeypaths;\n      // 遍历监听的 keypath，如果未被监听，则无需触发任何事件\n      each$2(watcher, function (_, watchKeypath) {\n          // 模糊监听，如 users.*.name\n          if (isFuzzy(watchKeypath)) {\n              // 如果当前修改的是 users.0 整个对象\n              // users.0 和 users.*.name 无法匹配\n              // 此时要知道设置 users.0 到底会不会改变 users.*.name 需要靠递归了\n              // 如果匹配，则无需递归\n              if (isDef(matchFuzzy(keypath, watchKeypath))) {\n                  callback(watchKeypath, keypath, newValue, oldValue);\n              }\n              else if (isRecursive) {\n                  if (fuzzyKeypaths) {\n                      push(fuzzyKeypaths, watchKeypath);\n                  }\n                  else {\n                      fuzzyKeypaths = [watchKeypath];\n                  }\n              }\n              return;\n          }\n          // 不是模糊匹配，直接靠前缀匹配\n          // 比如监听的是 users.0.name，此时修改 users.0，则直接读出子属性值，判断是否相等\n          var length = match(watchKeypath, keypath);\n          if (length >= 0) {\n              var subKeypath = slice(watchKeypath, length), subNewValue = readValue(newValue, subKeypath), subOldValue = readValue(oldValue, subKeypath);\n              if (subNewValue !== subOldValue) {\n                  callback(watchKeypath, watchKeypath, subNewValue, subOldValue);\n              }\n          }\n      });\n      // 存在模糊匹配的需求\n      // 必须对数据进行递归\n      // 性能确实会慢一些，但是很好用啊，几乎可以监听所有的数据\n      if (fuzzyKeypaths) {\n          diffRecursion(keypath, newValue, oldValue, fuzzyKeypaths, callback);\n      }\n  }\n\n  /**\n   * 触发异步变化时，用此函数过滤下，哪些 listener 应该执行\n   *\n   * @param item\n   * @param data\n   */\n  function filterWatcher (_, args, options) {\n      if (options.count && args) {\n          // 采用计数器的原因是，同一个 options 可能执行多次\n          // 比如监听 user.*，如果同批次修改了 user.name 和 user.age\n          // 这个监听器会调用多次，如果第一次执行就把 count 干掉了，第二次就无法执行了\n          options.count--;\n          // 新旧值不相等\n          return args[0] !== args[1];\n      }\n  }\n\n  // 避免频繁创建对象\n  var optionsHolder = {\n      watcher: EMPTY_FUNCTION\n  };\n  /**\n   * 格式化 watch options\n   *\n   * @param options\n   */\n  function formatWatcherOptions (options, immediate) {\n      if (func(options)) {\n          optionsHolder.watcher = options;\n          optionsHolder.immediate = immediate === TRUE;\n          return optionsHolder;\n      }\n      if (options && options.watcher) {\n          return options;\n      }\n      {\n          fatal(\"watcher should be a function or object.\");\n      }\n  }\n\n  /**\n   * 观察者有两种观察模式：\n   *\n   * 1. 同步监听\n   * 2. 异步监听\n   *\n   * 对于`计算属性`这种需要实时变化的对象，即它的依赖变了，它需要立即跟着变，否则会出现不一致的问题\n   * 这种属于同步监听\n   *\n   * 对于外部调用 observer.watch('keypath', listener)，属于异步监听，它只关心是否变了，而不关心是否是立即触发的\n   */\n  var Observer = /** @class */ (function () {\n      function Observer(data, context) {\n          var instance = this;\n          instance.data = data || {};\n          instance.context = context || instance;\n          instance.nextTask = new NextTask();\n          instance.syncEmitter = new Emitter();\n          instance.asyncEmitter = new Emitter();\n          instance.asyncChanges = {};\n      }\n      /**\n       * 获取数据\n       *\n       * @param keypath\n       * @param defaultValue\n       * @param depIgnore\n       * @return\n       */\n      Observer.prototype.get = function (keypath, defaultValue, depIgnore) {\n          var instance = this, currentComputed = Computed.current, data = instance.data, computed = instance.computed, reversedComputedKeys = instance.reversedComputedKeys;\n          // 传入 '' 获取整个 data\n          if (keypath === EMPTY_STRING) {\n              return data;\n          }\n          // 调用 get 时，外面想要获取依赖必须设置是谁在收集依赖\n          // 如果没设置，则跳过依赖收集\n          if (currentComputed && !depIgnore) {\n              currentComputed.add(keypath);\n          }\n          var result, target;\n          if (computed) {\n              target = computed[keypath];\n              if (target) {\n                  return target.get();\n              }\n              if (reversedComputedKeys) {\n                  var match = matchBest(reversedComputedKeys, keypath);\n                  if (match && match.prop) {\n                      result = get(computed[match.name].get(), match.prop);\n                  }\n              }\n          }\n          if (!result) {\n              result = get(data, keypath);\n          }\n          return result ? result.value : defaultValue;\n      };\n      /**\n       * 更新数据\n       *\n       * @param keypath\n       * @param value\n       */\n      Observer.prototype.set = function (keypath, value) {\n          var instance = this, data = instance.data, computed = instance.computed, reversedComputedKeys = instance.reversedComputedKeys, setValue = function (newValue, keypath) {\n              var oldValue = instance.get(keypath);\n              if (newValue === oldValue) {\n                  return;\n              }\n              var target;\n              if (computed) {\n                  target = computed[keypath];\n                  if (target) {\n                      target.set(newValue);\n                  }\n                  if (reversedComputedKeys) {\n                      var match = matchBest(reversedComputedKeys, keypath);\n                      if (match && match.prop) {\n                          target = computed[match.name];\n                          if (target) {\n                              var targetValue = target.get();\n                              if (object(targetValue)) {\n                                  set(targetValue, match.prop, newValue);\n                              }\n                          }\n                      }\n                  }\n              }\n              if (!target) {\n                  set(data, keypath, newValue);\n              }\n              instance.diff(keypath, newValue, oldValue);\n          };\n          if (string(keypath)) {\n              setValue(value, keypath);\n          }\n          else if (object(keypath)) {\n              each$2(keypath, setValue);\n          }\n      };\n      /**\n       * 同步调用的 diff，用于触发 syncEmitter，以及唤醒 asyncEmitter\n       *\n       * @param keypath\n       * @param newValue\n       * @param oldValue\n       */\n      Observer.prototype.diff = function (keypath, newValue, oldValue) {\n          var instance = this, syncEmitter = instance.syncEmitter, asyncEmitter = instance.asyncEmitter, asyncChanges = instance.asyncChanges, \n          /**\n           * 我们认为 $ 开头的变量是不可递归的\n           * 比如浏览器中常见的 $0 表示当前选中元素\n           * DOM 元素是不能递归的\n           */\n          isRecursive = codeAt(keypath) !== 36;\n          diffWatcher(keypath, newValue, oldValue, syncEmitter.listeners, isRecursive, function (watchKeypath, keypath, newValue, oldValue) {\n              syncEmitter.fire(watchKeypath, [newValue, oldValue, keypath]);\n          });\n          /**\n           * 此处有坑，举个例子\n           *\n           * observer.watch('a', function () {})\n           *\n           * observer.set('a', 1)\n           *\n           * observer.watch('a', function () {})\n           *\n           * 这里，第一个 watcher 应该触发，但第二个不应该，因为它绑定监听时，值已经是最新的了\n           */\n          diffWatcher(keypath, newValue, oldValue, asyncEmitter.listeners, isRecursive, function (watchKeypath, keypath, newValue, oldValue) {\n              each(asyncEmitter.listeners[watchKeypath], function (item) {\n                  item.count++;\n              });\n              var keypaths = (asyncChanges[keypath] || (asyncChanges[keypath] = { value: oldValue, keypaths: [] })).keypaths;\n              if (!has(keypaths, watchKeypath)) {\n                  push(keypaths, watchKeypath);\n              }\n              if (!instance.pending) {\n                  instance.pending = TRUE;\n                  instance.nextTask.append(function () {\n                      if (instance.pending) {\n                          instance.pending = UNDEFINED;\n                          instance.diffAsync();\n                      }\n                  });\n              }\n          });\n      };\n      /**\n       * 异步触发的 diff\n       */\n      Observer.prototype.diffAsync = function () {\n          var instance = this, asyncEmitter = instance.asyncEmitter, asyncChanges = instance.asyncChanges;\n          instance.asyncChanges = {};\n          each$2(asyncChanges, function (change, keypath) {\n              var args = [instance.get(keypath), change.value, keypath];\n              // 不能在这判断新旧值是否相同，相同就不 fire\n              // 因为前面标记了 count，在这中断会导致 count 无法清除\n              each(change.keypaths, function (watchKeypath) {\n                  asyncEmitter.fire(watchKeypath, args, filterWatcher);\n              });\n          });\n      };\n      /**\n       * 添加计算属性\n       *\n       * @param keypath\n       * @param computed\n       */\n      Observer.prototype.addComputed = function (keypath, options) {\n          var instance = this, computed = Computed.build(keypath, instance, options);\n          if (computed) {\n              if (!instance.computed) {\n                  instance.computed = {};\n              }\n              instance.computed[keypath] = computed;\n              instance.reversedComputedKeys = sort(instance.computed, TRUE);\n              return computed;\n          }\n      };\n      /**\n       * 移除计算属性\n       *\n       * @param keypath\n       */\n      Observer.prototype.removeComputed = function (keypath) {\n          var instance = this, computed = instance.computed;\n          if (computed && has$2(computed, keypath)) {\n              delete computed[keypath];\n              instance.reversedComputedKeys = sort(computed, TRUE);\n          }\n      };\n      /**\n       * 监听数据变化\n       *\n       * @param keypath\n       * @param watcher\n       * @param immediate\n       */\n      Observer.prototype.watch = function (keypath, watcher, immediate) {\n          var instance = this, context = instance.context, syncEmitter = instance.syncEmitter, asyncEmitter = instance.asyncEmitter, bind = function (keypath, options) {\n              var emitter = options.sync ? syncEmitter : asyncEmitter, \n              // formatWatcherOptions 保证了 options.watcher 一定存在\n              listener = {\n                  fn: options.watcher,\n                  ctx: context,\n                  count: 0\n              };\n              if (options.once) {\n                  listener.max = 1;\n              }\n              emitter.on(keypath, listener);\n              if (options.immediate) {\n                  execute(options.watcher, context, [\n                      instance.get(keypath),\n                      UNDEFINED,\n                      keypath\n                  ]);\n              }\n          };\n          if (string(keypath)) {\n              bind(keypath, formatWatcherOptions(watcher, immediate));\n              return;\n          }\n          each$2(keypath, function (options, keypath) {\n              bind(keypath, formatWatcherOptions(options));\n          });\n      };\n      /**\n       * 取消监听数据变化\n       *\n       * @param keypath\n       * @param watcher\n       */\n      Observer.prototype.unwatch = function (keypath, watcher) {\n          this.syncEmitter.off(keypath, watcher);\n          this.asyncEmitter.off(keypath, watcher);\n      };\n      /**\n       * 取反 keypath 对应的数据\n       *\n       * 不管 keypath 对应的数据是什么类型，操作后都是布尔型\n       *\n       * @param keypath\n       * @return 取反后的布尔值\n       */\n      Observer.prototype.toggle = function (keypath) {\n          var value = !this.get(keypath);\n          this.set(keypath, value);\n          return value;\n      };\n      /**\n       * 递增 keypath 对应的数据\n       *\n       * 注意，最好是整型的加法，如果涉及浮点型，不保证计算正确\n       *\n       * @param keypath 值必须能转型成数字，如果不能，则默认从 0 开始递增\n       * @param step 步进值，默认是 1\n       * @param max 可以递增到的最大值，默认不限制\n       */\n      Observer.prototype.increase = function (keypath, step, max) {\n          var value = toNumber(this.get(keypath), 0) + (step || 1);\n          if (!number(max) || value <= max) {\n              this.set(keypath, value);\n              return value;\n          }\n      };\n      /**\n       * 递减 keypath 对应的数据\n       *\n       * 注意，最好是整型的减法，如果涉及浮点型，不保证计算正确\n       *\n       * @param keypath 值必须能转型成数字，如果不能，则默认从 0 开始递减\n       * @param step 步进值，默认是 1\n       * @param min 可以递减到的最小值，默认不限制\n       */\n      Observer.prototype.decrease = function (keypath, step, min) {\n          var value = toNumber(this.get(keypath), 0) - (step || 1);\n          if (!number(min) || value >= min) {\n              this.set(keypath, value);\n              return value;\n          }\n      };\n      /**\n       * 在数组指定位置插入元素\n       *\n       * @param keypath\n       * @param item\n       * @param index\n       */\n      Observer.prototype.insert = function (keypath, item, index) {\n          var list = this.get(keypath);\n          list = !array(list) ? [] : copy(list);\n          var length = list.length;\n          if (index === TRUE || index === length) {\n              list.push(item);\n          }\n          else if (index === FALSE || index === 0) {\n              list.unshift(item);\n          }\n          else if (index > 0 && index < length) {\n              list.splice(index, 0, item);\n          }\n          else {\n              return;\n          }\n          this.set(keypath, list);\n          return TRUE;\n      };\n      /**\n       * 在数组尾部添加元素\n       *\n       * @param keypath\n       * @param item\n       */\n      Observer.prototype.append = function (keypath, item) {\n          return this.insert(keypath, item, TRUE);\n      };\n      /**\n       * 在数组首部添加元素\n       *\n       * @param keypath\n       * @param item\n       */\n      Observer.prototype.prepend = function (keypath, item) {\n          return this.insert(keypath, item, FALSE);\n      };\n      /**\n       * 通过索引移除数组中的元素\n       *\n       * @param keypath\n       * @param index\n       */\n      Observer.prototype.removeAt = function (keypath, index) {\n          var list = this.get(keypath);\n          if (array(list)\n              && index >= 0\n              && index < list.length) {\n              list = copy(list);\n              list.splice(index, 1);\n              this.set(keypath, list);\n              return TRUE;\n          }\n      };\n      /**\n       * 直接移除数组中的元素\n       *\n       * @param keypath\n       * @param item\n       */\n      Observer.prototype.remove = function (keypath, item) {\n          var list = this.get(keypath);\n          if (array(list)) {\n              list = copy(list);\n              if (remove(list, item)) {\n                  this.set(keypath, list);\n                  return TRUE;\n              }\n          }\n      };\n      /**\n       * 拷贝任意数据，支持深拷贝\n       *\n       * @param data\n       * @param deep\n       */\n      Observer.prototype.copy = function (data, deep) {\n          return copy(data, deep);\n      };\n      /**\n       * 销毁\n       */\n      Observer.prototype.destroy = function () {\n          var instance = this;\n          instance.syncEmitter.off();\n          instance.asyncEmitter.off();\n          instance.nextTask.clear();\n          clear(instance);\n      };\n      return Observer;\n  }());\n\n  // 这里先写 IE9 支持的接口\n  var innerText = 'textContent', innerHTML = 'innerHTML', findElement = function (selector) {\n      var node = DOCUMENT.querySelector(selector);\n      if (node) {\n          return node;\n      }\n  }, addEventListener = function (node, type, listener) {\n      node.addEventListener(type, listener, FALSE);\n  }, removeEventListener = function (node, type, listener) {\n      node.removeEventListener(type, listener, FALSE);\n  }, \n  // IE9 不支持 classList\n  addClass = function (node, className) {\n      node.classList.add(className);\n  }, removeClass = function (node, className) {\n      node.classList.remove(className);\n  }, createEvent = function (event, node) {\n      return event;\n  };\n  if (DOCUMENT) {\n      // 此时 document.body 不一定有值，比如 script 放在 head 里\n      if (!DOCUMENT.documentElement.classList) {\n          addClass = function (node, className) {\n              var classes = node.className.split(CHAR_WHITESPACE);\n              if (!has(classes, className)) {\n                  push(classes, className);\n                  node.className = join(classes, CHAR_WHITESPACE);\n              }\n          };\n          removeClass = function (node, className) {\n              var classes = node.className.split(CHAR_WHITESPACE);\n              if (remove(classes, className)) {\n                  node.className = join(classes, CHAR_WHITESPACE);\n              }\n          };\n      }\n  }\n  var CHAR_WHITESPACE = ' ', \n  /**\n   * 绑定在 HTML 元素上的事件发射器\n   */\n  EMITTER = '$emitter', \n  /**\n   * 跟输入事件配套使用的事件\n   */\n  COMPOSITION_START = 'compositionstart', \n  /**\n   * 跟输入事件配套使用的事件\n   */\n  COMPOSITION_END = 'compositionend', domain = 'http://www.w3.org/', namespaces = {\n      svg: domain + '2000/svg'\n  }, specialEvents = {}, domApi = {\n      createElement: function (tag, isSvg) {\n          return isSvg\n              ? DOCUMENT.createElementNS(namespaces.svg, tag)\n              : DOCUMENT.createElement(tag);\n      },\n      createText: function (text) {\n          return DOCUMENT.createTextNode(text);\n      },\n      createComment: function (text) {\n          return DOCUMENT.createComment(text);\n      },\n      prop: function (node, name, value) {\n          if (isDef(value)) {\n              set(node, name, value, FALSE);\n          }\n          else {\n              var holder = get(node, name);\n              if (holder) {\n                  return holder.value;\n              }\n          }\n      },\n      removeProp: function (node, name, hint) {\n          set(node, name, hint === HINT_BOOLEAN\n              ? FALSE\n              : EMPTY_STRING, FALSE);\n      },\n      attr: function (node, name, value) {\n          if (isDef(value)) {\n              node.setAttribute(name, value);\n          }\n          else {\n              // value 还可能是 null\n              var value_1 = node.getAttribute(name);\n              if (value_1 != NULL) {\n                  return value_1;\n              }\n          }\n      },\n      removeAttr: function (node, name) {\n          node.removeAttribute(name);\n      },\n      before: function (parentNode, node, beforeNode) {\n          parentNode.insertBefore(node, beforeNode);\n      },\n      append: function (parentNode, node) {\n          parentNode.appendChild(node);\n      },\n      replace: function (parentNode, node, oldNode) {\n          parentNode.replaceChild(node, oldNode);\n      },\n      remove: function (parentNode, node) {\n          parentNode.removeChild(node);\n      },\n      parent: function (node) {\n          var parentNode = node.parentNode;\n          if (parentNode) {\n              return parentNode;\n          }\n      },\n      next: function (node) {\n          var nextSibling = node.nextSibling;\n          if (nextSibling) {\n              return nextSibling;\n          }\n      },\n      find: findElement,\n      tag: function (node) {\n          if (node.nodeType === 1) {\n              return lower(node.tagName);\n          }\n      },\n      text: function (node, text, isStyle) {\n          if (isDef(text)) {\n              {\n                  node[innerText] = text;\n              }\n          }\n          else {\n              return node[innerText];\n          }\n      },\n      html: function (node, html, isStyle) {\n          if (isDef(html)) {\n              {\n                  node[innerHTML] = html;\n              }\n          }\n          else {\n              return node[innerHTML];\n          }\n      },\n      addClass: addClass,\n      removeClass: removeClass,\n      on: function (node, type, listener) {\n          var emitter = node[EMITTER] || (node[EMITTER] = new Emitter()), nativeListeners = emitter.nativeListeners || (emitter.nativeListeners = {});\n          // 一个元素，相同的事件，只注册一个 native listener\n          if (!nativeListeners[type]) {\n              // 特殊事件\n              var special = specialEvents[type], \n              // 唯一的原生监听器\n              nativeListener = function (event) {\n                  var customEvent = event instanceof CustomEvent\n                      ? event\n                      : new CustomEvent(event.type, createEvent(event, node));\n                  if (customEvent.type !== type) {\n                      customEvent.type = type;\n                  }\n                  emitter.fire(type, [customEvent]);\n              };\n              nativeListeners[type] = nativeListener;\n              if (special) {\n                  special.on(node, nativeListener);\n              }\n              else {\n                  addEventListener(node, type, nativeListener);\n              }\n          }\n          emitter.on(type, listener);\n      },\n      off: function (node, type, listener) {\n          var emitter = node[EMITTER], listeners = emitter.listeners, nativeListeners = emitter.nativeListeners;\n          // emitter 会根据 type 和 listener 参数进行适当的删除\n          emitter.off(type, listener);\n          // 如果注册的 type 事件都解绑了，则去掉原生监听器\n          if (nativeListeners && !emitter.has(type)) {\n              var special = specialEvents[type], nativeListener = nativeListeners[type];\n              if (special) {\n                  special.off(node, nativeListener);\n              }\n              else {\n                  removeEventListener(node, type, nativeListener);\n              }\n              delete nativeListeners[type];\n          }\n          if (falsy$2(listeners)) {\n              node[EMITTER] = UNDEFINED;\n          }\n      },\n      addSpecialEvent: function (type, hooks) {\n          {\n              if (specialEvents[type]) {\n                  error(\"Special event \\\"\" + type + \"\\\" is existed.\");\n              }\n              info(\"Special event \\\"\" + type + \"\\\" add success.\");\n          }\n          specialEvents[type] = hooks;\n      }\n  };\n  specialEvents[EVENT_MODEL] = {\n      on: function (node, listener) {\n          var locked = FALSE;\n          domApi.on(node, COMPOSITION_START, listener[COMPOSITION_START] = function () {\n              locked = TRUE;\n          });\n          domApi.on(node, COMPOSITION_END, listener[COMPOSITION_END] = function (event) {\n              locked = FALSE;\n              listener(event);\n          });\n          addEventListener(node, EVENT_INPUT, listener[EVENT_INPUT] = function (event) {\n              if (!locked) {\n                  listener(event);\n              }\n          });\n      },\n      off: function (node, listener) {\n          domApi.off(node, COMPOSITION_START, listener[COMPOSITION_START]);\n          domApi.off(node, COMPOSITION_END, listener[COMPOSITION_END]);\n          removeEventListener(node, EVENT_INPUT, listener[EVENT_INPUT]);\n          listener[COMPOSITION_START] =\n              listener[COMPOSITION_END] =\n                  listener[EVENT_INPUT] = UNDEFINED;\n      }\n  };\n\n  /**\n   * 节流调用\n   *\n   * @param fn 需要节制调用的函数\n   * @param delay 调用的时间间隔，单位毫秒\n   * @param immediate 是否立即触发\n   * @return 节流函数\n   */\n  function debounce (fn, delay, immediate) {\n      var timer;\n      return function () {\n          if (!timer) {\n              var args_1 = toArray(arguments);\n              if (immediate) {\n                  execute(fn, UNDEFINED, args_1);\n              }\n              timer = setTimeout(function () {\n                  timer = UNDEFINED;\n                  if (!immediate) {\n                      execute(fn, UNDEFINED, args_1);\n                  }\n              }, delay);\n          }\n      };\n  }\n\n  var directive = {\n      bind: function (node, directive, vnode) {\n          var name = directive.name, handler = directive.handler, lazy = vnode.lazy;\n          if (!handler) {\n              return;\n          }\n          if (lazy) {\n              var value = lazy[name] || lazy[EMPTY_STRING];\n              if (value === TRUE) {\n                  name = EVENT_CHANGE;\n              }\n              else if (value > 0) {\n                  handler = debounce(handler, value, \n                  // 避免连续多次点击，主要用于提交表单场景\n                  // 移动端的 tap 事件可自行在业务层打补丁实现\n                  name === EVENT_CLICK || name === EVENT_TAP);\n              }\n          }\n          if (vnode.isComponent) {\n              node.on(name, handler);\n              vnode.data[directive.key] = function () {\n                  node.off(name, handler);\n              };\n          }\n          else {\n              domApi.on(node, name, handler);\n              vnode.data[directive.key] = function () {\n                  domApi.off(node, name, handler);\n              };\n          }\n      },\n      unbind: function (node, directive, vnode) {\n          execute(vnode.data[directive.key]);\n      }\n  };\n\n  function getOptionValue(option) {\n      return isDef(option.value)\n          ? option.value\n          : option.text;\n  }\n  var inputControl = {\n      set: function (node, value) {\n          node.value = toString(value);\n      },\n      sync: function (node, keypath, context) {\n          context.set(keypath, node.value);\n      },\n      name: RAW_VALUE\n  }, radioControl = {\n      set: function (node, value) {\n          node.checked = node.value === toString(value);\n      },\n      sync: function (node, keypath, context) {\n          if (node.checked) {\n              context.set(keypath, node.value);\n          }\n      },\n      name: 'checked'\n  }, checkboxControl = {\n      set: function (node, value) {\n          node.checked = array(value)\n              ? has(value, node.value, FALSE)\n              : !!value;\n      },\n      sync: function (node, keypath, context) {\n          var value = context.get(keypath);\n          if (array(value)) {\n              if (node.checked) {\n                  context.append(keypath, node.value);\n              }\n              else {\n                  context.removeAt(keypath, indexOf(value, node.value, FALSE));\n              }\n          }\n          else {\n              context.set(keypath, node.checked);\n          }\n      },\n      name: 'checked'\n  }, selectControl = {\n      set: function (node, value) {\n          each(toArray(node.options), node.multiple\n              ? function (option) {\n                  option.selected = has(value, getOptionValue(option), FALSE);\n              }\n              : function (option, index) {\n                  if (getOptionValue(option) == value) {\n                      node.selectedIndex = index;\n                      return FALSE;\n                  }\n              });\n      },\n      sync: function (node, keypath, context) {\n          var options = toArray(node.options);\n          if (node.multiple) {\n              var values_1 = [];\n              each(options, function (option) {\n                  if (option.selected) {\n                      push(values_1, getOptionValue(option));\n                  }\n              });\n              context.set(keypath, values_1);\n          }\n          else {\n              context.set(keypath, getOptionValue(options[node.selectedIndex]));\n          }\n      },\n      name: RAW_VALUE\n  }, inputTypes = {\n      radio: radioControl,\n      checkbox: checkboxControl\n  }, directive$1 = {\n      bind: function (node, directive, vnode) {\n          var context = vnode.context, model = vnode.model, lazy = vnode.lazy, isComponent = vnode.isComponent, dataBinding = directive.binding, viewBinding, eventName, set, sync, lazyValue;\n          if (lazy) {\n              lazyValue = lazy[DIRECTIVE_MODEL] || lazy[EMPTY_STRING];\n          }\n          if (isComponent) {\n              viewBinding = node.$options.model || RAW_VALUE;\n              set = function (newValue) {\n                  node.set(viewBinding, newValue);\n              };\n              sync = function (newValue) {\n                  context.set(dataBinding, newValue);\n              };\n          }\n          else {\n              var control_1 = domApi.tag(node) === 'select'\n                  ? selectControl\n                  : inputControl;\n              // checkbox,radio,select 监听的是 change 事件\n              eventName = EVENT_CHANGE;\n              if (control_1 === inputControl) {\n                  var type_1 = node.type;\n                  if (inputTypes[type_1]) {\n                      control_1 = inputTypes[type_1];\n                  }\n                  // 如果是输入框，则切换成 model 事件\n                  // model 事件是个 yox-dom 实现的特殊事件\n                  // 不会在输入法组合文字过程中得到触发事件\n                  else if (lazyValue !== TRUE) {\n                      eventName = EVENT_MODEL;\n                  }\n              }\n              set = function (newValue) {\n                  control_1.set(node, newValue);\n              };\n              sync = function () {\n                  control_1.sync(node, dataBinding, context);\n              };\n          }\n          // 不管模板是否设值，统一用数据中的值\n          set(model, UNDEFINED, EMPTY_STRING);\n          // 应用 lazy\n          if (lazyValue && lazyValue !== TRUE) {\n              sync = debounce(sync, lazyValue);\n          }\n          // 监听交互，修改数据\n          if (isComponent) {\n              node.watch(viewBinding, sync);\n          }\n          else {\n              domApi.on(node, eventName, sync);\n          }\n          // 监听数据，修改界面\n          context.watch(dataBinding, set);\n          vnode.data[directive.key] = function () {\n              if (isComponent) {\n                  node.unwatch(viewBinding, sync);\n              }\n              else {\n                  domApi.off(node, eventName, sync);\n              }\n              context.unwatch(dataBinding, set);\n          };\n      },\n      unbind: function (node, directive, vnode) {\n          execute(vnode.data[directive.key]);\n      }\n  };\n\n  var directive$2 = {\n      bind: function (node, directive, vnode) {\n          // binding 可能是模糊匹配\n          // 比如延展属性 {{...obj}}，这里 binding 会是 `obj.*`\n          var binding = directive.binding, isFuzzy$1 = isFuzzy(binding), watcher = function (newValue, _, keypath) {\n              var name = isFuzzy$1\n                  ? matchFuzzy(keypath, binding)\n                  : directive.name;\n              if (vnode.isComponent) {\n                  node.set(name, newValue);\n              }\n              else if (isDef(directive.hint)) {\n                  domApi.prop(node, name, newValue);\n              }\n              else {\n                  domApi.attr(node, name, newValue);\n              }\n          };\n          vnode.context.watch(binding, watcher);\n          vnode.data[directive.key] = function () {\n              vnode.context.unwatch(binding, watcher);\n          };\n      },\n      unbind: function (node, directive, vnode) {\n          execute(vnode.data[directive.key]);\n      }\n  };\n\n  // this type https://jkchao.github.io/typescript-book-chinese/typings/thisType.html\n  /**\n   * 组件是否存在某个 slot\n   *\n   * @param name\n   */\n  function hasSlot (name) {\n      return isDef(this.get(SLOT_DATA_PREFIX + name));\n  }\n\n  var globalDirectives = {}, globalTransitions = {}, globalComponents = {}, globalPartials = {}, globalFilters = {}, LOADER_QUEUE = '$queue', TEMPLATE_COMPUTED = '$' + RAW_TEMPLATE, selectorPattern = /^[#.][-\\w+]+$/;\n  var Yox = /** @class */ (function () {\n      function Yox(options) {\n          var instance = this, $options = options || EMPTY_OBJECT;\n          // 一进来就执行 before create\n          execute($options[HOOK_BEFORE_CREATE], instance, $options);\n          instance.$options = $options;\n          var data = $options.data, props = $options.props, computed = $options.computed, events = $options.events, methods = $options.methods, watchers = $options.watchers, extensions = $options.extensions;\n          // 如果传了 props，则 data 应该是个 function\n          {\n              if (props && object(data)) {\n                  fatal('\"data\" option should be a function.');\n              }\n          }\n          if (extensions) {\n              extend(instance, extensions);\n          }\n          // 数据源\n          var source = instance.checkPropTypes(props || {});\n          // 先放 props\n          // 当 data 是函数时，可以通过 this.get() 获取到外部数据\n          var observer = instance.$observer = new Observer(source, instance);\n          if (computed) {\n              each$2(computed, function (options, keypath) {\n                  observer.addComputed(keypath, options);\n              });\n          }\n          // 后放 data\n          var extend$1 = func(data) ? execute(data, instance, options) : data;\n          if (object(extend$1)) {\n              each$2(extend$1, function (value, key) {\n                  {\n                      if (has$2(source, key)) {\n                          warn(\"\\\"\" + key + \"\\\" is already defined as a prop. Use prop default value instead.\");\n                      }\n                  }\n                  source[key] = value;\n              });\n          }\n          if (methods) {\n              each$2(methods, function (method, name) {\n                  {\n                      if (instance[name]) {\n                          fatal(\"method [\" + name + \"] is conflicted with built-in methods.\");\n                      }\n                  }\n                  instance[name] = method;\n              });\n          }\n          // 监听各种事件\n          // 支持命名空间\n          instance.$emitter = new Emitter(TRUE);\n          if (events) {\n              instance.on(events);\n          }\n          {\n              var placeholder = UNDEFINED, el = $options.el, vnode = $options.vnode, root = $options.root, parent = $options.parent, replace = $options.replace, template = $options.template, transitions = $options.transitions, components = $options.components, directives = $options.directives, partials = $options.partials, filters = $options.filters, slots = $options.slots;\n              // 把 slots 放进数据里，方便 get\n              if (slots) {\n                  extend(source, slots);\n              }\n              // 检查 template\n              if (string(template)) {\n                  // 传了选择器，则取对应元素的 html\n                  if (selectorPattern.test(template)) {\n                      placeholder = domApi.find(template);\n                      if (placeholder) {\n                          template = domApi.html(placeholder);\n                          placeholder = UNDEFINED;\n                      }\n                      else {\n                          fatal(\"\\\"\" + template + \"\\\" \\u9009\\u62E9\\u5668\\u627E\\u4E0D\\u5230\\u5BF9\\u5E94\\u7684\\u5143\\u7D20\");\n                      }\n                  }\n              }\n              else {\n                  template = UNDEFINED;\n              }\n              // 检查 el\n              if (el) {\n                  if (string(el)) {\n                      var selector = el;\n                      if (selectorPattern.test(selector)) {\n                          placeholder = domApi.find(selector);\n                          {\n                              if (!placeholder) {\n                                  fatal(\"\\\"\" + selector + \"\\\" \\u9009\\u62E9\\u5668\\u627E\\u4E0D\\u5230\\u5BF9\\u5E94\\u7684\\u5143\\u7D20\");\n                              }\n                          }\n                      }\n                      else {\n                          fatal(\"\\\"el\\\" option should be a selector.\");\n                      }\n                  }\n                  else {\n                      placeholder = el;\n                  }\n                  if (!replace) {\n                      domApi.append(placeholder, placeholder = domApi.createComment(EMPTY_STRING));\n                  }\n              }\n              if (root) {\n                  instance.$root = root;\n              }\n              if (parent) {\n                  instance.$parent = parent;\n              }\n              setFlexibleOptions(instance, RAW_TRANSITION, transitions);\n              setFlexibleOptions(instance, RAW_COMPONENT, components);\n              setFlexibleOptions(instance, RAW_DIRECTIVE, directives);\n              setFlexibleOptions(instance, RAW_PARTIAL, partials);\n              setFlexibleOptions(instance, RAW_FILTER, filters);\n              // 当存在模板和计算属性时\n              // 因为这里把模板当做一种特殊的计算属性\n              // 因此模板这个计算属性的优先级应该最高\n              if (template) {\n                  // 拷贝一份，避免影响外部定义的 watchers\n                  var newWatchers = watchers\n                      ? copy(watchers)\n                      : {};\n                  newWatchers[TEMPLATE_COMPUTED] = {\n                      // 模板一旦变化，立即刷新\n                      sync: TRUE,\n                      watcher: function (vnode) {\n                          instance.update(vnode, instance.$vnode);\n                      }\n                  };\n                  // 当模板的依赖变了，则重新创建 virtual dom\n                  observer.addComputed(TEMPLATE_COMPUTED, {\n                      // 当模板依赖变化时，异步通知模板更新\n                      sync: FALSE,\n                      get: function () {\n                          return instance.render();\n                      }\n                  });\n                  afterCreateHook(instance, newWatchers);\n                  // 编译模板\n                  // 在开发阶段，template 是原始的 html 模板\n                  // 在产品阶段，template 是编译后且经过 stringify 的字符串\n                  // 当然，这个需要外部自己控制传入的 template 是什么\n                  // Yox.compile 会自动判断 template 是否经过编译\n                  instance.$template = Yox.compile(template);\n                  if (!vnode) {\n                      {\n                          if (!placeholder) {\n                              fatal('根组件不传 el 是几个意思？');\n                          }\n                      }\n                      vnode = create(domApi, placeholder, instance, EMPTY_STRING);\n                  }\n                  instance.update(instance.get(TEMPLATE_COMPUTED), vnode);\n                  return;\n              }\n              else {\n                  if (placeholder || vnode) {\n                      fatal('组件不写 template 是几个意思？');\n                  }\n              }\n          }\n          afterCreateHook(instance, watchers);\n      }\n      /**\n       * 安装插件\n       *\n       * 插件必须暴露 install 方法\n       */\n      Yox.use = function (plugin) {\n          plugin.install(Yox);\n      };\n      /**\n       * 因为组件采用的是异步更新机制，为了在更新之后进行一些操作，可使用 nextTick\n       */\n      Yox.nextTick = function (task, context) {\n          NextTask.shared().append(task, context);\n      };\n      /**\n       * 编译模板，暴露出来是为了打包阶段的模板预编译\n       */\n      Yox.compile = function (template, stringify$1) {\n          {\n              {\n                  if (!hasStringify(template)) {\n                      // 未编译，常出现在开发阶段\n                      var nodes = compile$1(template);\n                      {\n                          if (nodes.length !== 1) {\n                              fatal(\"\\\"template\\\" should have just one root element.\");\n                          }\n                      }\n                      template = stringify(nodes[0]);\n                      if (stringify$1) {\n                          return template;\n                      }\n                  }\n              }\n              return new Function(\"return \" + template)();\n          }\n      };\n      Yox.directive = function (name, directive) {\n          {\n              if (string(name) && !directive) {\n                  return getResource(globalDirectives, name);\n              }\n              setResource(globalDirectives, name, directive);\n          }\n      };\n      Yox.transition = function (name, transition) {\n          {\n              if (string(name) && !transition) {\n                  return getResource(globalTransitions, name);\n              }\n              setResource(globalTransitions, name, transition);\n          }\n      };\n      Yox.component = function (name, component) {\n          {\n              if (string(name) && !component) {\n                  return getResource(globalComponents, name);\n              }\n              setResource(globalComponents, name, component);\n          }\n      };\n      Yox.partial = function (name, partial) {\n          {\n              if (string(name) && !partial) {\n                  return getResource(globalPartials, name);\n              }\n              setResource(globalPartials, name, partial, Yox.compile);\n          }\n      };\n      Yox.filter = function (name, filter) {\n          {\n              if (string(name) && !filter) {\n                  return getResource(globalFilters, name);\n              }\n              setResource(globalFilters, name, filter);\n          }\n      };\n      /**\n       * 添加计算属性\n       */\n      Yox.prototype.addComputed = function (keypath, computed) {\n          return this.$observer.addComputed(keypath, computed);\n      };\n      /**\n       * 删除计算属性\n       */\n      Yox.prototype.removeComputed = function (keypath) {\n          this.$observer.removeComputed(keypath);\n      };\n      /**\n       * 取值\n       */\n      Yox.prototype.get = function (keypath, defaultValue, depIgnore) {\n          return this.$observer.get(keypath, defaultValue, depIgnore);\n      };\n      /**\n       * 设值\n       */\n      Yox.prototype.set = function (keypath, value) {\n          // 组件经常有各种异步改值，为了避免组件销毁后依然调用 set\n          // 这里判断一下，至于其他方法的异步调用就算了，业务自己控制吧\n          var $observer = this.$observer;\n          if ($observer) {\n              $observer.set(keypath, value);\n          }\n      };\n      /**\n       * 监听事件\n       */\n      Yox.prototype.on = function (type, listener) {\n          return addEvents(this, type, listener);\n      };\n      /**\n       * 监听一次事件\n       */\n      Yox.prototype.once = function (type, listener) {\n          return addEvents(this, type, listener, TRUE);\n      };\n      /**\n       * 取消监听事件\n       */\n      Yox.prototype.off = function (type, listener) {\n          this.$emitter.off(type, listener);\n          return this;\n      };\n      /**\n       * 发射事件\n       */\n      Yox.prototype.fire = function (type, data, downward) {\n          // 外部为了使用方便，fire(type) 或 fire(type, data) 就行了\n          // 内部为了保持格式统一\n          // 需要转成 Event，这样还能知道 target 是哪个组件\n          var instance = this, event = type instanceof CustomEvent ? type : new CustomEvent(type), args = [event], isComplete;\n          // 告诉外部是谁发出的事件\n          if (!event.target) {\n              event.target = instance;\n          }\n          // 比如 fire('name', true) 直接向下发事件\n          if (object(data)) {\n              push(args, data);\n          }\n          else if (data === TRUE) {\n              downward = TRUE;\n          }\n          isComplete = instance.$emitter.fire(event.type, args);\n          if (isComplete) {\n              var $parent = instance.$parent, $children = instance.$children;\n              if (downward) {\n                  if ($children) {\n                      event.phase = CustomEvent.PHASE_DOWNWARD;\n                      each($children, function (child) {\n                          return isComplete = child.fire(event, data, TRUE);\n                      });\n                  }\n              }\n              else if ($parent) {\n                  event.phase = CustomEvent.PHASE_UPWARD;\n                  isComplete = $parent.fire(event, data);\n              }\n          }\n          return isComplete;\n      };\n      /**\n       * 监听数据变化\n       */\n      Yox.prototype.watch = function (keypath, watcher, immediate) {\n          this.$observer.watch(keypath, watcher, immediate);\n          return this;\n      };\n      /**\n       * 取消监听数据变化\n       */\n      Yox.prototype.unwatch = function (keypath, watcher) {\n          this.$observer.unwatch(keypath, watcher);\n          return this;\n      };\n      /**\n       * 加载组件，组件可以是同步或异步，最后会调用 callback\n       *\n       * @param name 组件名称\n       * @param callback 组件加载成功后的回调\n       */\n      Yox.prototype.loadComponent = function (name, callback) {\n          if (!loadComponent(this.$components, name, callback)) {\n              loadComponent(globalComponents, name, callback);\n          }\n      };\n      /**\n       * 创建子组件\n       *\n       * @param options 组件配置\n       * @param vnode 虚拟节点\n       */\n      Yox.prototype.createComponent = function (options, vnode) {\n          {\n              var instance = this;\n              options = copy(options);\n              options.root = instance.$root || instance;\n              options.parent = instance;\n              options.vnode = vnode;\n              options.replace = TRUE;\n              if (vnode.props) {\n                  options.props = vnode.props;\n              }\n              if (vnode.slots) {\n                  options.slots = vnode.slots;\n              }\n              var child = new Yox(options);\n              push(instance.$children || (instance.$children = []), child);\n              var node = child.$el;\n              if (node) {\n                  vnode.node = node;\n              }\n              else {\n                  fatal(\"The root element of [Component \" + vnode.tag + \"] is not found.\");\n              }\n              return child;\n          }\n      };\n      Yox.prototype.directive = function (name, directive) {\n          {\n              var instance = this, $directives = instance.$directives;\n              if (string(name) && !directive) {\n                  return getResource($directives, name, Yox.directive);\n              }\n              setResource($directives || (instance.$directives = {}), name, directive);\n          }\n      };\n      Yox.prototype.transition = function (name, transition) {\n          {\n              var instance = this, $transitions = instance.$transitions;\n              if (string(name) && !transition) {\n                  return getResource($transitions, name, Yox.transition);\n              }\n              setResource($transitions || (instance.$transitions = {}), name, transition);\n          }\n      };\n      Yox.prototype.component = function (name, component) {\n          {\n              var instance = this, $components = instance.$components;\n              if (string(name) && !component) {\n                  return getResource($components, name, Yox.component);\n              }\n              setResource($components || (instance.$components = {}), name, component);\n          }\n      };\n      Yox.prototype.partial = function (name, partial) {\n          {\n              var instance = this, $partials = instance.$partials;\n              if (string(name) && !partial) {\n                  return getResource($partials, name, Yox.partial);\n              }\n              setResource($partials || (instance.$partials = {}), name, partial, Yox.compile);\n          }\n      };\n      Yox.prototype.filter = function (name, filter) {\n          {\n              var instance = this, $filters = instance.$filters;\n              if (string(name) && !filter) {\n                  return getResource($filters, name, Yox.filter);\n              }\n              setResource($filters || (instance.$filters = {}), name, filter);\n          }\n      };\n      /**\n       * 对于某些特殊场景，修改了数据，但是模板的依赖中并没有这一项\n       * 而你非常确定需要更新模板，强制刷新正是你需要的\n       */\n      Yox.prototype.forceUpdate = function () {\n          {\n              var instance = this, $vnode = instance.$vnode, $observer = instance.$observer, computed = $observer.computed;\n              if ($vnode && computed) {\n                  var template = computed[TEMPLATE_COMPUTED], oldValue = template.get();\n                  // 当前可能正在进行下一轮更新\n                  $observer.nextTask.run();\n                  // 没有更新模板，强制刷新\n                  if (oldValue === template.get()) {\n                      instance.update(template.get(TRUE), $vnode);\n                  }\n              }\n          }\n      };\n      /**\n       * 把模板抽象语法树渲染成 virtual dom\n       */\n      Yox.prototype.render = function () {\n          {\n              var instance = this;\n              return render(instance, instance.$template, mergeResource(instance.$filters, globalFilters), mergeResource(instance.$partials, globalPartials), mergeResource(instance.$directives, globalDirectives), mergeResource(instance.$transitions, globalTransitions));\n          }\n      };\n      /**\n       * 更新 virtual dom\n       *\n       * @param vnode\n       * @param oldVnode\n       */\n      Yox.prototype.update = function (vnode, oldVnode) {\n          {\n              var instance_1 = this, $vnode = instance_1.$vnode, $options = instance_1.$options, hook_1;\n              // 每次渲染重置 refs\n              // 在渲染过程中收集最新的 ref\n              // 这样可避免更新时，新的 ref，在前面创建，老的 ref 却在后面删除的情况\n              instance_1.$refs = {};\n              if ($vnode) {\n                  execute($options[HOOK_BEFORE_UPDATE], instance_1);\n                  patch(domApi, vnode, oldVnode);\n                  hook_1 = $options[HOOK_AFTER_UPDATE];\n              }\n              else {\n                  execute($options[HOOK_BEFORE_MOUNT], instance_1);\n                  patch(domApi, vnode, oldVnode);\n                  instance_1.$el = vnode.node;\n                  hook_1 = $options[HOOK_AFTER_MOUNT];\n              }\n              instance_1.$vnode = vnode;\n              // 跟 nextTask 保持一个节奏\n              // 这样可以预留一些优化的余地\n              if (hook_1) {\n                  instance_1.nextTick(function () {\n                      if (instance_1.$vnode) {\n                          execute(hook_1, instance_1);\n                      }\n                  });\n              }\n          }\n      };\n      /**\n       * 校验组件参数\n       *\n       * @param props\n       */\n      Yox.prototype.checkPropTypes = function (props) {\n          {\n              var propTypes = this.$options.propTypes;\n              if (propTypes) {\n                  var result_1 = copy(props);\n                  each$2(propTypes, function (rule, key) {\n                      // 类型\n                      var type = rule.type, \n                      // 默认值\n                      value = rule.value, \n                      // 实际的值\n                      actual = props[key];\n                      // 传了数据\n                      if (isDef(actual)) {\n                          {\n                              // 如果不写 type 或 type 不是 字符串 或 数组\n                              // 就当做此规则无效，和没写一样\n                              if (type) {\n                                  // 自定义函数判断是否匹配类型\n                                  // 自己打印警告信息吧\n                                  if (func(type)) {\n                                      type(props, key);\n                                  }\n                                  else {\n                                      var matched_1;\n                                      // type: 'string'\n                                      if (!falsy$1(type)) {\n                                          matched_1 = matchType(actual, type);\n                                      }\n                                      // type: ['string', 'number']\n                                      else if (!falsy(type)) {\n                                          each(type, function (item) {\n                                              if (matchType(actual, item)) {\n                                                  matched_1 = TRUE;\n                                                  return FALSE;\n                                              }\n                                          });\n                                      }\n                                      if (!matched_1) {\n                                          warn(\"The type of prop \\\"\" + key + \"\\\" expected to be \\\"\" + type + \"\\\", but is \\\"\" + actual + \"\\\".\");\n                                      }\n                                  }\n                              }\n                              else {\n                                  warn(\"The prop \\\"\" + key + \"\\\" in propTypes has no type.\");\n                              }\n                          }\n                      }\n                      else {\n                          {\n                              // 是否必传\n                              var required = rule.required;\n                              // 动态化获取是否必填\n                              if (func(required)) {\n                                  required = required(props, key);\n                              }\n                              // 没传值但此项是必传项\n                              if (required) {\n                                  warn(\"The prop \\\"\" + key + \"\\\" is marked as required, but its value is not found.\");\n                              }\n                          }\n                          // 没传值但是配置了默认值\n                          if (isDef(value)) {\n                              result_1[key] = type === RAW_FUNCTION\n                                  ? value\n                                  : func(value)\n                                      ? value(props, key)\n                                      : value;\n                          }\n                      }\n                  });\n                  return result_1;\n              }\n          }\n          return props;\n      };\n      /**\n       * 销毁组件\n       */\n      Yox.prototype.destroy = function () {\n          var instance = this, $options = instance.$options, $emitter = instance.$emitter, $observer = instance.$observer;\n          execute($options[HOOK_BEFORE_DESTROY], instance);\n          {\n              var $vnode = instance.$vnode, $parent = instance.$parent;\n              if ($parent && $parent.$children) {\n                  remove($parent.$children, instance);\n              }\n              if ($vnode) {\n                  // virtual dom 通过判断 parent.$vnode 知道宿主组件是否正在销毁\n                  instance.$vnode = UNDEFINED;\n                  destroy(domApi, $vnode, !$parent);\n              }\n          }\n          $emitter.off();\n          $observer.destroy();\n          clear(instance);\n          execute($options[HOOK_AFTER_DESTROY], instance);\n      };\n      /**\n       * 因为组件采用的是异步更新机制，为了在更新之后进行一些操作，可使用 nextTick\n       */\n      Yox.prototype.nextTick = function (task) {\n          this.$observer.nextTask.append(task, this);\n      };\n      /**\n       * 取反 keypath 对应的数据\n       *\n       * 不管 keypath 对应的数据是什么类型，操作后都是布尔型\n       */\n      Yox.prototype.toggle = function (keypath) {\n          return this.$observer.toggle(keypath);\n      };\n      /**\n       * 递增 keypath 对应的数据\n       *\n       * 注意，最好是整型的加法，如果涉及浮点型，不保证计算正确\n       *\n       * @param keypath 值必须能转型成数字，如果不能，则默认从 0 开始递增\n       * @param step 步进值，默认是 1\n       * @param max 可以递增到的最大值，默认不限制\n       */\n      Yox.prototype.increase = function (keypath, step, max) {\n          return this.$observer.increase(keypath, step, max);\n      };\n      /**\n       * 递减 keypath 对应的数据\n       *\n       * 注意，最好是整型的减法，如果涉及浮点型，不保证计算正确\n       *\n       * @param keypath 值必须能转型成数字，如果不能，则默认从 0 开始递减\n       * @param step 步进值，默认是 1\n       * @param min 可以递减到的最小值，默认不限制\n       */\n      Yox.prototype.decrease = function (keypath, step, min) {\n          return this.$observer.decrease(keypath, step, min);\n      };\n      /**\n       * 在数组指定位置插入元素\n       *\n       * @param keypath\n       * @param item\n       * @param index\n       */\n      Yox.prototype.insert = function (keypath, item, index) {\n          return this.$observer.insert(keypath, item, index);\n      };\n      /**\n       * 在数组尾部添加元素\n       *\n       * @param keypath\n       * @param item\n       */\n      Yox.prototype.append = function (keypath, item) {\n          return this.$observer.append(keypath, item);\n      };\n      /**\n       * 在数组首部添加元素\n       *\n       * @param keypath\n       * @param item\n       */\n      Yox.prototype.prepend = function (keypath, item) {\n          return this.$observer.prepend(keypath, item);\n      };\n      /**\n       * 通过索引移除数组中的元素\n       *\n       * @param keypath\n       * @param index\n       */\n      Yox.prototype.removeAt = function (keypath, index) {\n          return this.$observer.removeAt(keypath, index);\n      };\n      /**\n       * 直接移除数组中的元素\n       *\n       * @param keypath\n       * @param item\n       */\n      Yox.prototype.remove = function (keypath, item) {\n          return this.$observer.remove(keypath, item);\n      };\n      /**\n       * 拷贝任意数据，支持深拷贝\n       *\n       * @param data\n       * @param deep\n       */\n      Yox.prototype.copy = function (data, deep) {\n          return this.$observer.copy(data, deep);\n      };\n      /**\n       * core 版本\n       */\n      Yox.version = \"1.0.0-alpha.35\";\n      /**\n       * 方便外部共用的通用逻辑，特别是写插件，减少重复代码\n       */\n      Yox.is = is;\n      Yox.array = array$1;\n      Yox.object = object$1;\n      Yox.string = string$1;\n      Yox.logger = logger;\n      Yox.Event = CustomEvent;\n      Yox.Emitter = Emitter;\n      return Yox;\n  }());\n  var toString$1 = Object.prototype.toString;\n  function matchType(value, type) {\n      return type === 'numeric'\n          ? numeric(value)\n          : lower(toString$1.call(value)) === \"[object \" + type + \"]\";\n  }\n  function afterCreateHook(instance, watchers) {\n      if (watchers) {\n          instance.watch(watchers);\n      }\n      execute(instance.$options[HOOK_AFTER_CREATE], instance);\n  }\n  function setFlexibleOptions(instance, key, value) {\n      if (func(value)) {\n          instance[key](execute(value, instance));\n      }\n      else if (object(value)) {\n          instance[key](value);\n      }\n  }\n  function addEvent(instance, type, listener, once) {\n      var options = {\n          fn: listener,\n          ctx: instance\n      };\n      if (once) {\n          options.max = 1;\n      }\n      instance.$emitter.on(type, options);\n  }\n  function addEvents(instance, type, listener, once) {\n      if (string(type)) {\n          addEvent(instance, type, listener, once);\n      }\n      else {\n          each$2(type, function (value, key) {\n              addEvent(instance, key, value, once);\n          });\n      }\n      return instance;\n  }\n  function loadComponent(data, name, callback) {\n      if (data && data[name]) {\n          var component = data[name];\n          // 注册的是异步加载函数\n          if (func(component)) {\n              var loader_1 = component, queue_1 = loader_1[LOADER_QUEUE];\n              if (queue_1) {\n                  push(queue_1, callback);\n              }\n              else {\n                  queue_1 = component[LOADER_QUEUE] = [callback];\n                  loader_1(function (options) {\n                      loader_1[LOADER_QUEUE] = UNDEFINED;\n                      data[name] = options;\n                      each(queue_1, function (callback) {\n                          callback(options);\n                      });\n                  });\n              }\n          }\n          // 不是异步加载函数，直接同步返回\n          else {\n              callback(component);\n          }\n          return TRUE;\n      }\n  }\n  function getResource(data, name, lookup) {\n      if (data && data[name]) {\n          return data[name];\n      }\n      else if (lookup) {\n          return lookup(name);\n      }\n  }\n  function setResource(data, name, value, formatValue) {\n      if (string(name)) {\n          data[name] = formatValue ? formatValue(value) : value;\n      }\n      else {\n          each$2(name, function (value, key) {\n              data[key] = formatValue ? formatValue(value) : value;\n          });\n      }\n  }\n  function mergeResource(locals, globals) {\n      return locals && globals\n          ? extend({}, globals, locals)\n          : locals || globals;\n  }\n  {\n      Yox['dom'] = domApi;\n      // 全局注册内置指令\n      Yox.directive({ event: directive, model: directive$1, binding: directive$2 });\n      // 全局注册内置过滤器\n      Yox.filter({ hasSlot: hasSlot });\n  }\n\n  return Yox;\n\n}));\n//# sourceMappingURL=yox.js.map\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/yox/dist/standard/dev/yox.js?");

/***/ })

}]);